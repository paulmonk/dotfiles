<!-- Generated by: just coding-agents -->
<!-- Source: claude/CLAUDE.md + claude/rules/*.md -->
<!-- Do not edit directly -->

# Global Defaults

Global instructions for all projects. Project-specific AGENTS.md or CLAUDE.md
files override these defaults.

Assume other agents or the user might land commits mid-run;
refresh context before summarising or editing.

Use skills proactively when they match the task. Suggest
relevant ones, don't block on them

## Quick Obligations

| Situation                     | Required action                                                                          |
| ----------------------------- | ---------------------------------------------------------------------------------------- |
| Tool or command hangs         | If a command runs longer than 5 minutes, stop it, capture logs, and check with the user. |
| Reviewing git status or diffs | Treat them as read-only context; never revert or assume missing changes were yours.      |
| Adding a dependency           | Research well-maintained options and confirm fit with the user before adding.             |

## Philosophy

- **Think hard, do not lose the plot**. Instead of applying a
  bandaid, fix things from first principles. Find the source and
  fix it versus applying a cheap bandaid on top.
- **No speculative features**. Do not add features, flags, or
  configuration unless users actively need them. Do not document
  or validate features that are not implemented.
- **No premature abstraction**. Do not create utilities until
  the same code has been written three times. Three similar lines
  is better than the wrong abstraction.
- **Clarity over cleverness**. Write idiomatic, simple,
  maintainable code. Prefer explicit, readable code over dense
  one-liners. If code is hard to follow, simplify it first;
  add an ASCII art or Mermaid diagram if structure is still
  unclear.
- **Justify new dependencies**. Each dependency is attack surface
  and maintenance burden.
- **No phantom features**. Don't document or validate features
  that aren't implemented
- **Replace, do not deprecate**. When a new implementation
  replaces an old one, remove the old one entirely. No
  backward-compatible shims, dual config formats, or migration
  paths. No breadcrumbs ("// moved to X", "// removed"). Clean
  up unused code ruthlessly: dead parameters, dead helpers,
  dead files.
- **Verify at every level**. Set up automated guardrails
  (linters, type checkers, tests) as the first step, not an
  afterthought. Prefer structure-aware tools (`ast-grep`, LSPs,
  compilers) over text pattern matching. Review your own output.
- **Bias toward action**. Decide and move for anything easily
  reversed; state your assumption so the reasoning is visible.
  Ask before committing to interfaces, data models,
  architecture, or destructive operations on external services.
- **Finish the job**. Handle the edge cases you can see. Clean
  up what you touched. If something is broken adjacent to your
  change, flag it. But do not invent new scope: there is a
  difference between thoroughness and gold-plating.
- **Agent-native by default**. Design so agents can achieve any outcome
  users can. Tools are atomic primitives; features are outcomes described
  in prompts. Prefer file-based state for transparency and portability.
  When adding UI capability, ask: can an agent achieve this outcome too?
- **Search before pivoting**. If you are stuck or uncertain, do a
  quick web search for official docs or specs, then continue with
  the current approach. Do not change direction unless asked.

## Tool Preferences

| tool | replaces | usage |
|------|----------|-------|
| `exa` MCP | WebSearch/WebFetch | `mcp__exa__web_search_exa` |
| `context7` MCP | - | `mcp__context7__resolve-library-id` then `mcp__context7__query-docs` |
| `deepwiki` MCP | - | `mcp__deepwiki__ask_question` or `mcp__deepwiki__read_wiki_contents` |
| `serena` MCP | - | `mcp__serena__find_symbol`, `mcp__serena__get_symbols_overview` |
| `rg` (ripgrep) | grep | `rg "pattern"` - 10x faster regex search |
| `fd` | find | `fd "*.py"` - fast file finder |
| `ast-grep` | - | `ast-grep --pattern '$FUNC($$$)' --lang py` - AST-based code search |
| `semgrep` | - | `semgrep --config auto` - semantic static analysis |
| `shellcheck` | - | `shellcheck script.sh` - shell script linter |
| `shfmt` | - | `shfmt -i 2 -w script.sh` - shell formatter |
| `actionlint` | - | `actionlint .github/workflows/` - GitHub Actions linter |
| `zizmor` | - | `zizmor .github/workflows/` - Actions security audit |
| `prek` | pre-commit | `prek run` - fast git hooks (Rust, no Python) |
| `wt` | git worktree | `wt switch branch` - manage parallel worktrees |
| `bd` | - | Issue tracking and task management |
| `trash` | rm | `trash file` - moves to macOS Trash (recoverable). **Never use `rm -rf`** |

### Tooling Workflow

- **Task runner**. If a `justfile` exists, prefer `just` for
  build, test, and lint. If no `justfile` exists, look for a
  `Makefile` and use `make` if the file exists.
- **Git safety**: Do not run destructive git commands
  (`reset --hard`, `checkout .`, `clean -f`, `push --force`)
  without explicit permission.
- **Git worktrees**: Create worktrees with
  `wt switch -c <branch>` (uses `.worktrees/` at repository
  root). Use `wt list` to view, `wt merge <target>` to
  squash-merge back, `wt remove` to clean up.

## Knowledge Base

Use **qmd** MCP server to search the Obsidian vault
(research topics, daily notes)

- `search` for keyword matching, `vsearch` for semantic
  similarity, `query` for structured filters.
- Previous conversation summaries are in the **qmd**
  `*-memory-episodes` collections.

## Coding Standards

### Comments

- **Explain the why, not the what.** Comments should cover
  non-obvious business logic, algorithm rationale, or
  implementation choices. Avoid restating what the code does.
- Complete sentences. Block comments: `#` followed by a space.

### Error handling

- Fail fast with clear, actionable messages
- Never swallow exceptions silently
- Include context (what operation, what input, suggested fix)

### Zero warnings policy

Fix every warning from every tool: linters, type checkers, compilers, tests.
If a warning truly can't be fixed, add an inline ignore with a justification
comment. Never leave warnings unaddressed; a clean output is the baseline,
not the goal.

### Commit Messages

Use Conventional Commits style:

| Rule    | Convention                                              |
| ------- | ------------------------------------------------------- |
| Format  | `<type>(<scope>): <description>` with optional body     |
| Types   | `feat`, `fix`, `refactor`, `docs`, `test`, `chore`      |
| Subject | Lowercase after type, present tense, 50 chars or less   |
| Body    | Blank line after subject, wrap at 72 chars, explain why |

## Testing

- **Test behavior, not implementation.** Tests should verify
  what code does, not how. If a refactor breaks your tests but
  not your code, the tests were wrong.
- **Test edges and errors, not just the happy path.** Empty
  inputs, boundaries, malformed data, missing files, network
  failures, bugs live in edges. Every error path the code
  handles should have a test that triggers it.
- **Mock boundaries, not logic.** Only mock things that are
  slow (network, filesystem), non-deterministic (time,
  randomness), or external services you don't control.
- **Verify tests catch failures.** Break the code, confirm the
  test fails, then fix. Use mutation testing (`cargo-mutants`,
  `mutmut`) to verify systematically. Use property-based
  testing (`proptest`, `hypothesis`) for parsers,
  serialization, and algorithms.

## Workflow

When taking on new work:

1. Think about the architecture.
2. Research official docs, blogs, or papers on the best
   architecture.
3. Review the existing codebase.
4. Compare the research with the codebase to choose the best
   fit.
5. Implement the fix or ask about the tradeoffs the user is
   willing to make.

Before finishing a task:

1. Re-read your changes for unnecessary complexity, redundant code,
   and unclear naming.
2. Run relevant tests, not the full suite.
3. Run linters and type checker, fix everything before committing.
4. Summarise changes with file and line references.
5. Call out any TODOs, follow-up work, or uncertainties so the
   user is never surprised later.

## GitHub Actions

### Tooling

| Purpose  | Tool         |
| -------- | ------------ |
| Lint     | `actionlint` |
| Security | `zizmor`     |

### Security

- **Pin actions to SHA hashes** with a version comment:

  ```yaml
  - uses: actions/checkout@2541b1294d2704b0964813337f33b291d3f8596b  # v3.0.2
    with:
      persist-credentials: false
  ```

  Never pin to tags (`@v3`) or branches (`@main`).

- **persist-credentials: false** on all `actions/checkout`
  steps. This prevents the token from persisting in the
  git config where subsequent steps could extract it.
- **Least privilege tokens**. Use `permissions` at the job
  level (not workflow level) and grant only what's needed.
  Start with `permissions: {}` and add back selectively.

  ```yaml
  jobs:
    build:
      permissions:
        contents: read
  ```

- **No secrets in plain text**. Use `${{ secrets.NAME }}`
  for credentials. Never echo secrets or pass them as
  command-line arguments (visible in process listings).
- **Avoid `pull_request_target`** unless you understand the
  security implications. Prefer `pull_request` for untrusted
  code.
- **Scan workflows** with `zizmor` before committing to
  catch common security issues.

### Structure

- **One concern per workflow file**. Separate CI, release,
  and deployment into distinct files.
- **Descriptive names**. Name workflows and jobs clearly:

  ```yaml
  name: CI
  jobs:
    lint:
      name: Lint and format
  ```

- **Reusable workflows** for shared logic across repos.
  Use `workflow_call` trigger with explicit inputs and
  secrets.
- **Concurrency control**. Cancel in-progress runs for the
  same branch to save resources:

  ```yaml
  concurrency:
    group: ${{ github.workflow }}-${{ github.ref }}
    cancel-in-progress: true
  ```

- **Timeouts**. Set `timeout-minutes` on jobs to prevent
  stuck workflows. Default is 360 minutes which is far
  too generous for most jobs.

### Best Practices

- **Cache dependencies**. Use `actions/cache` or built-in
  caching (e.g. `setup-node` with `cache: pnpm`) to speed
  up builds.
- **Matrix strategies** for testing across versions. Use
  `fail-fast: false` to see all failures:

  ```yaml
  strategy:
    fail-fast: false
    matrix:
      os: [ubuntu-latest, macos-latest]
      node: [20, 22]
  ```

- **Expressions over scripts**. Prefer `if:` conditions
  over shell conditionals for job/step control.
- **Outputs over artefacts** for small values passed
  between jobs. Use artefacts for files.

### Dependabot

Configure Dependabot with cooldowns and grouped updates
to reduce noise:

```yaml
## .github/dependabot.yml
version: 2
updates:
  - package-ecosystem: github-actions
    directory: /
    schedule:
      interval: weekly
    groups:
      actions:
        patterns: ["*"]
```

## Go

### Tooling

| Purpose | Tool                                                  |
| ------- | ----------------------------------------------------- |
| Build   | `go build ./...`                                      |
| Test    | `go test ./...`                                       |
| Lint    | `go vet ./...` · `staticcheck ./...` · `revive ./...` |
| Format  | `gofmt -w .`                                          |

### General Best Practices

- Use the standard library where possible. Only pull in
  dependencies when they provide significant value.
- Design zero values to be useful; users should be able
  to use a type immediately after declaration.
- **Naming:** No `Get` prefix on getters (`Owner()` not
  `GetOwner()`). Single-method interfaces use method
  name + "-er" suffix (`Reader`, `Writer`).
- **Variable names:** Length proportional to scope. Short
  names (1-3 chars) in small scopes, descriptive names
  for exported identifiers and wider scopes.
- **Receiver names:** Keep short (1-2 letters),
  abbreviate the type name, apply consistently across
  all methods of a type.
- **Initialisms:** Maintain consistent casing (`URL`,
  `HTTP`, `ID` not `Url`, `Http`, `Id`). All caps for
  initialisms regardless of position.
- **Packages:** Name for what they provide, not generic
  terms like "util" or "helper". Consider how the call
  site reads.
- **Control flow:** Avoid unnecessary `else` when `if`
  ends with `return`/`break`/`continue`. Indent error
  handling before happy path.
- **Initialisation:** Use `if err := ...; err != nil` to
  scope variables tightly. Prefer `:=` for non-zero
  values, `var` for zero-value declarations.
- **Composite literals:** Use field labels
  (`Name: value`) for resilience to struct changes.
  Omit explicit zeros when zero values suffice.
- **Shadowing:** Avoid shadowing package names or outer
  variables. Use explicit assignment (`=`) instead of
  `:=` in nested scopes when reusing variables.
- **Defer:** Use for cleanup (close files, unlock
  mutexes). Args evaluate at defer time, not call time
  (common gotcha).
- **Generics:** Use `any` instead of `interface{}`.
  Prefer generic functions over type-specific variants
  when appropriate.

### Imports

- **Grouping order:** Standard library, then project
  packages, then third-party packages. Separate groups
  with blank lines.
- **Renaming:** Rename imports only to avoid collisions.
  Use names following package naming rules.
- **Dot imports:** Never use; impairs code clarity and
  grep-ability.
- **Blank imports:** Only in main packages or tests for
  side effects; avoid in libraries.

### Context

- **First parameter:** `context.Context` is always the
  first parameter, named `ctx`.
- **Never store in structs:** Pass context through
  function parameters, not struct fields.
- **Propagate cancellation:** Pass the context you
  receive to downstream calls; don't create new
  background contexts mid-call-chain.
- **Custom types:** Never create custom context key types
  that shadow the standard library.

### Data Structures

- **Slices:** Use `slices` package for common operations
  (`slices.Contains`, `slices.Sort`). Prefer `nil`
  slices over empty initialised slices in function
  signatures. Preallocate capacity only when final size
  is known empirically.
- **Maps:** Use comma-ok idiom to distinguish missing
  keys from zero values. Use `maps` package for
  operations like `maps.Clone`.
- **Embedding:** Promoted methods receive the inner type
  as receiver, not outer (can surprise you).

### Interfaces

- **Define where consumed:** Define interfaces in the
  package that uses them, not the package that
  implements them.
- **Compile-time compliance:** Verify with
  `var _ Interface = (*Type)(nil)`.
- **Channel direction:** Specify (`chan<-`, `<-chan`) to
  convey ownership and catch mistakes at compile time.
- **Accept/Return:** Accept interfaces, return concrete
  types (unless swapping implementations is expected).

### Types and Receivers

- **Pointer receivers:** Use for methods that mutate
  state, for large structs, or when in doubt.
- **Value receivers:** Use for small immutable types,
  basic types, or when the type is naturally a value
  (like `time.Time`).
- **Consistency:** All methods on a type should use the
  same receiver type when possible.
- **Pass values:** Avoid pointer parameters for small
  types; use pointers for large structs or when mutation
  is needed.
- **Copying:** Never copy structs containing
  `sync.Mutex`, `sync.WaitGroup`, or similar
  synchronisation primitives.

### Concurrency

- **Philosophy:** Share memory by communicating, not the
  other way around.
- **Goroutine lifetime:** Make lifetimes explicit. Use
  `context.Context` for cancellation or
  `sync.WaitGroup` to track completion. Never
  fire-and-forget.
- **Channels:** Unbuffered for synchronisation, buffered
  for throughput. Use `select` with `default` for
  non-blocking ops.
- **Patterns:** Buffered channel as semaphore; worker
  pool reading from shared channel; channel of channels
  for request/response.
- **Synchronous by default:** Prefer synchronous
  functions; let callers add concurrency. Don't force
  async on consumers.
- **Documentation:** Document mutating operations'
  thread-safety. Readers assume read-only ops are safe
  unless stated otherwise.

### Error Handling

- **Explicit handling:** Handle all errors explicitly. Do
  not use `_` to ignore errors unless there is a clear
  reason documented in a comment.
- **Errors over panics:** Prefer returning errors over
  panicking. Reserve `panic` for truly unrecoverable
  situations or API misuse (like reflect).
- **Return type:** Return `error` interface, not concrete
  error types, as the final return value.
- **Custom errors:** Create custom error types
  implementing `Error() string` for rich context
  (like `os.PathError`).
- **Error strings:** Lowercase, no trailing punctuation,
  identify origin (e.g.,
  `"mypackage: failed to open"`).
- **Wrapped errors:** Use `errors.Is()` for wrapped
  errors, simple `==` for sentinel values.
- **Adding context:** Add context without duplicating
  what the underlying error provides. Use `%w` to
  preserve error chain for programmatic inspection,
  `%v` to hide implementation details. Place `%w` at
  the end of format strings.
- **Logging:** Avoid duplicate logging; return errors and
  let callers decide whether to log. Prefer `log/slog`
  for structured logging.
- **Initialisation failures:** Use `log.Fatal` for
  initialisation failures, not `panic`. Internal
  panic-recover must never escape package boundaries.

### Documentation

- **Doc comments:** Required for all exported names.
  Start with the name being documented.
- **Complete sentences:** Use proper capitalisation and
  punctuation in doc comments.
- **Concurrency safety:** Document mutating operations
  that are not thread-safe. Readers assume read-only
  operations are safe for concurrent use.
- **Cleanup requirements:** Explicitly document when and
  how to clean up resources (Close, Stop, Cancel).
- **Examples:** Include runnable examples in `_test.go`
  files for complex APIs; they appear in godoc.

### Testing

- **No assertion libraries:** Use standard `if` checks
  and `t.Error`/`t.Fatal`. Use `cmp.Diff` from
  `github.com/google/go-cmp/cmp` for complex
  comparisons.
- **Failure messages:** Include function name, inputs,
  and "got vs want" in failure messages.
- **Table-driven tests:** Group related test cases in a
  slice of structs and loop over them. Use field names
  in literals for clarity.
- **Subtests:** Use `t.Run()` for grouped cases; enables
  selective test runs and parallel execution.
- **t.Error vs t.Fatal:** Use `t.Error` with `continue`
  for per-entry failures in table tests. Reserve
  `t.Fatal` for setup failures that prevent
  continuation.
- **Helpers:** Use `t.Helper()` in setup functions to
  correctly attribute failures.
- **Goroutines in tests:** Never call
  `t.Fatal`/`t.FailNow` from goroutines other than the
  test function; use `t.Error` and return.
- **Real transports:** Test with real HTTP/RPC transports
  connected to test-double backends rather than
  hand-implementing clients.

### Cryptography

- **Random numbers:** Use `crypto/rand` for
  security-sensitive randomness, never `math/rand`.

## Issue Tracking with Beads

When a project has a `.beads/` directory, use `bd` for all issue
tracking. Core commands are documented in the beads plugin
context; this file covers workflow policy.

### Plans Require Issues

When entering plan mode, ensure the work is tracked by a beads
issue. If you are already working on an existing issue, link
the plan to it. Otherwise, create an issue before writing the
plan.

Exceptions (no issue needed):

- Pure research or exploration with no code changes.
- The plan is a continuation of an issue already in context.

### Creating Issues

- Read the template from `~/.config/bd/templates/{type}.md`
  before creating.
- Always include `--acceptance` with checklist items.
- Apply area labels when creating issues.
- Run `bd lint <id>` after creating to verify compliance.

### Additional Commands

Commands not covered by the beads plugin context:

| Command                     | Purpose                               |
| --------------------------- | ------------------------------------- |
| `bd stale`                  | Find forgotten issues                 |
| `bd find-duplicates`        | Find semantically similar issues      |
| `bd defer <id>`             | Ice-box an issue (removes from ready) |
| `bd undefer <id>`           | Bring deferred issue back             |
| `bd graph --all`            | Visualise dependency DAG              |
| `bd query "expr"`           | Rich filtering with boolean ops       |
| `bd label add <id> <label>` | Add area label                        |
| `bd lint <id>`              | Validate issue template               |
| `bd lint`                   | Lint all open issues                  |

### Quality Checklist

- Before starting work: confirm the issue has acceptance criteria.
- Before closing: verify all acceptance criteria are met.

Issue types: `task`, `bug`, `feature`, `story`, `epic`, `spike`.
Priority: 0 (critical) to 4 (backlog).

## Python

### Tooling

| Purpose     | Tool                                        |
| ----------- | ------------------------------------------- |
| Deps & venv | `uv sync`                                   |
| Lint        | `uv run ruff check --fix`                   |
| Format      | `uv run ruff format`                        |
| Types       | `uv run ty check` (fallback: `uv run mypy`) |
| Tests       | `uv run pytest -q`                          |
| Build       | `uv_build` backend                          |

Do not introduce `pip`, Poetry, or `requirements.txt` unless
asked.

### General Best Practices

- **Constants:** Use immutable global constant
  collections (tuple, frozenset). Prefer constants over
  string/int literals, especially for dictionary keys,
  pathnames, and enums. Use `ALL_CAPS` naming.
- **Mutable globals:** Avoid mutable global state. If
  needed, declare at module level and treat as internal.
- **Comprehensions:** Use list, set, and dict
  comprehensions for simple cases. Avoid multiple `for`
  clauses or complex filter expressions; use loops
  instead.
- **Iteration:** Iterate directly over containers. Use
  `enumerate()` for indices, `dict.items()` for
  keys/values, `zip()` for parallel iteration.
- **Built-ins:** Leverage `all()`, `any()`,
  `reversed()`, `sum()`,
  `itertools.chain.from_iterable()` for flattening.
- **Generators:** Use for memory efficiency with large
  sequences. Document with `Yields:` section in
  docstrings.
- **Lambdas:** Use only for one-liners. Prefer generator
  expressions over `map()` or `filter()` with lambdas.
- **Decorators:** Use for cross-cutting concerns
  (logging, timing, caching). Use `functools.wraps()`
  to preserve metadata. Avoid `@staticmethod`; limit
  `@classmethod`.
- **Context managers:** Use `with` statements for
  resource management (files, locks, connections).
- **Single assignment:** Prefer single-assignment over
  assign-and-mutate. Use conditional expressions for
  simple cases.
- **Truthiness:** Use implicit false (`if not items:`)
  but always use explicit `if foo is None` to
  distinguish from other falsy values.
- **Default arguments:** NEVER use mutable default
  arguments. Use `None` as sentinel.
- **Properties:** Use `@property` for trivial
  computations. Avoid for expensive operations, side
  effects, or operations that can fail.
- **Modules for namespacing:** Use modules as primary
  namespacing mechanism, not classes. Avoid methods
  that don't use `self`.
- **Keyword-only by default:** Functions with more than
  one parameter should make all but the first
  keyword-only using `*`. Use `/` for positional-only
  when parameter names are implementation details.
  Dataclasses should also use `kw_only`.
- **Power features:** Avoid metaclasses, bytecode
  manipulation, and dynamic attribute access unless
  truly necessary.

### Imports

- **Style:** Use `import x` for packages and modules.
  Use `from x import y` only for typing,
  collections.abc, and specific items from large
  modules.
- **Grouping order:** Future imports, standard library,
  third-party packages, local imports. Separate groups
  with blank lines. Sort lexicographically within
  groups.
- **Full pathnames:** Always use absolute imports. Avoid
  relative imports except within package internals.
- **No wildcards:** Never use `from x import *`.
- **Datetime:** Use `import datetime as dt` rather than
  `from datetime import datetime`. Access via
  `dt.datetime`, `dt.timedelta`, etc.

### Naming

- **Conventions:** `module_name`, `package_name`,
  `ClassName`, `ExceptionName`, `CONSTANT_NAME`,
  `function_name`, `method_name`, `local_var_name`,
  `_private_name`.
- **Mappings:** Name like `value_by_key` to enhance
  readability (e.g., `item = item_by_id[id]`).
- **Avoid:** Single-character names except for iterators
  (`i`, `j`, `k`) and context managers (`f` for files).
  Avoid abbreviations unfamiliar to non-native
  speakers.
- **Protected/Private:** Use
  `_single_leading_underscore` for protected,
  `__double_leading_underscore` only to prevent
  subclass collisions.

### Type Annotations

- **Coverage:** Annotate public APIs and complex internal
  code.
- **Abstract types:** Use `collections.abc` (`Sequence`,
  `Mapping`, `Iterable`) over `typing` equivalents.
- **NewType:** Use `typing.NewType` to create distinct
  types from primitives for domain modelling.
- **Nullable:** Explicitly mark with `X | None`. Never
  leave implicit.
- **Forward references:** Use
  `from __future__ import annotations` or string quotes
  for forward declarations.
- **Aliases:** Create type aliases for complex types with
  `CapWord` names.
- **Containers:** Use `list[T]` for homogeneous
  sequences, `tuple[T, ...]` for variable-length,
  `tuple[T1, T2]` for fixed structure.
- **Final:** Only use Final type for true immutable constants.
  `Final` only prevents reassignment, not mutation.
  A `Final[dict]` can still be modified in place.
  Pair with immutable types (tuple, frozenset, `Mapping`, `Sequence`).

### Docstrings

- **Format:** Use triple double-quotes. First line is
  summary ending with period. Blank line before
  detailed description.
- **Functions/Methods:** Document parameters, return
  values, and exceptions using Args, Returns, and
  Raises sections.
- **Classes:** Describe what instances represent.
  Document public attributes in Attributes section.
- **Modules:** Start with description of contents and
  usage examples.

```python
def fetch_data(url: str, timeout: int = 30) -> dict[str, Any]:
    """Fetch JSON data from a URL.

    Args:
        url: The endpoint to fetch from.
        timeout: Request timeout in seconds.

    Returns:
        Parsed JSON response as a dictionary.

    Raises:
        RequestError: If the request fails or times out.
    """
```

### Threading

- **No atomicity assumptions:** Don't rely on built-in
  type atomicity. Use `queue` module or `threading`
  locks for thread-safe communication.
- **Prefer queues:** Use `queue.Queue` for
  producer-consumer patterns over shared mutable state.

### Main Guard

- **Always use:** Every executable script must have
  `if __name__ == '__main__':` guard.
- **Minimal code:** Keep code outside the guard minimal
  (imports, constants, definitions only).

```python
def main() -> None:
    ...

if __name__ == '__main__':
    main()
```

### Function Design

- **Length:** Prefer functions under 40 lines. Break
  longer functions into smaller, focused pieces.
- **Single responsibility:** Each function should do one
  thing well.
- **`__repr__()` vs `__str__()`:** Implement
  `__repr__()` for unambiguous, developer-focused
  strings. `__str__()` for human-readable output.

### Libraries and Tools

- **`collections.Counter`:** For efficiently counting
  hashable objects.
- **`collections.defaultdict`:** For avoiding key checks
  when initialising dictionary values.
- **`heapq`:** Use `nlargest()`, `nsmallest()`,
  `merge()` for efficient operations.
- **`attrs`/`dataclasses`:** Use for classes with
  auto-generated boilerplate methods.
- **Serialisation:** JSON for cross-language, `pydantic`
  for runtime validation, `cattrs` for performance with
  dataclasses/attrs.
- **Regular expressions:** Use `re.VERBOSE` for readable
  regexes. Compile regexes used multiple times. Avoid
  regexes for simple string checks.
- **Caching:** Use `functools.lru_cache` with care.
  Prefer immutable return types. Use
  `functools.cached_property` for methods.
- **Pickle:** Avoid due to security risks. Prefer JSON,
  Protocol Buffers, or msgpack.

### Testing

- **Function tests:** Use function-based pytest tests,
  not unittest classes.
- **Assertions:** Use pytest's native `assert` with
  informative expressions. Add custom messages when
  needed.
- **Parameterized tests:** Use
  `@pytest.mark.parametrize` to reduce duplication.
- **Fixtures:** Use pytest fixtures for setup, teardown,
  and dependency injection.
- **Mocking:** Use `mock.create_autospec()` with
  `spec_set=True`. Prefer injecting dependencies via
  fixtures over patching.
- **Temporary files:** Use pytest's `tmp_path` and
  `tmp_path_factory` fixtures.
- **Deterministic inputs:** Do not use random inputs in
  unit tests. Use deterministic, easy-to-reason-about
  inputs.
- **Test invariants:** Focus on invariant behaviours of
  public APIs, not implementation details.

### Error Handling

- **Bare except:** Never use bare `except:`. Always catch
  specific exceptions.
- **Scope:** Minimise try/except block scope. Only wrap
  the code that can raise.
- **Re-raising:** Use bare `raise` to preserve stack
  trace. Use `raise NewException from original` to
  chain. Use `raise NewException from None` to suppress
  context.
- **Messages:** Always include descriptive messages when
  raising.
- **Converting to strings:** `repr(e)` is often better
  than `str(e)`. Use `traceback` module for full
  details.
- **Returning None:** Be consistent. Use explicit
  `return None` if function can return values. Bare
  `return` only for `-> None` functions.

## Rust

### Tooling

| Purpose | Tool                                                             |
| ------- | ---------------------------------------------------------------- |
| Build   | `cargo build`                                                    |
| Test    | `cargo test`                                                     |
| Lint    | `cargo clippy --all --benches --tests --examples --all-features` |
| Format  | `cargo fmt`                                                      |

### General Best Practices

- Do NOT use unwraps or anything that can panic in Rust code,
  handle errors. Obviously in tests unwraps and panics are fine!
- Prefer `crate::` over `super::` for imports in non-test code.
  One-level `super::` in test modules is acceptable. If you see
  deep `super::super::` chains, refactor to use `crate::`.
- Avoid `pub use` on imports unless you are re-exposing a
  dependency so downstream consumers do not have to depend on it
  directly.
- Skip global state via `lazy_static!`, `Once`, or similar;
  prefer passing explicit context structs for any shared state.
- Prefer strong types over strings, use enums and newtypes when
  the domain is closed or needs validation.
- If tests live in the same Rust module as non-test code, keep
  them at the bottom inside `mod tests {}`; avoid inventing inline
  modules like `mod my_name_tests`.

### Cargo.toml Lints

When creating new Rust projects, include these clippy lints:

```toml
[lints.clippy]
pedantic = { level = "warn", priority = -1 }
## Panic prevention
unwrap_used = "deny"
expect_used = "warn"
panic = "deny"
panic_in_result_fn = "deny"
unimplemented = "deny"
## No cheating
allow_attributes = "deny"
## Code hygiene
dbg_macro = "deny"
todo = "deny"
print_stdout = "deny"
print_stderr = "deny"
## Safety
await_holding_lock = "deny"
large_futures = "deny"
exit = "deny"
mem_forget = "deny"
## Pedantic relaxations (too noisy)
module_name_repetitions = "allow"
similar_names = "allow"
```

## Shell

### Tooling

| Purpose | Tool             |
| ------- | ---------------- |
| Lint    | `shellcheck`     |
| Format  | `shfmt -i 2 -w`  |

### General Best Practices

- **Small utilities only:** Limit shell to small utilities,
  wrapper scripts, and glue code under 100 lines.
- **Consider alternatives:** If performance matters, control flow
  is complex, or the script exceeds 100 lines, use Python, Go, or
  another language.
- **No SUID/SGID:** Never use SUID or SGID on shell scripts. Use
  `sudo` for elevated access.

### Script Setup

- **Shebang:** Always start with `#!/bin/bash` or
  `#!/usr/bin/env bash`.
- **Strict mode:** Enable
  `set -o errexit -o errtrace -o pipefail -o nounset`.
- **Header comment:** Every file needs a comment describing its
  purpose.
- **File order:** Shebang, header comment, `set` options,
  constants, includes/sources, functions, main logic.
- **Extensions:** Executables may omit `.sh`; libraries must use
  `.sh` and be non-executable.

### Variables & Naming

- **Brace syntax:** Prefer `"${var}"` over `"$var"` for clarity.
- **Arrays for lists:** Use arrays for storing lists and
  command-line arguments.
- **Functions:** Lowercase with underscores. Use `::` prefix for
  namespacing (e.g., `mylib::init`).
- **Variables:** Lowercase with underscores for local variables.
- **Constants:** UPPERCASE with underscores, declared at file top
  with `readonly` or `declare -r`.

### Control Flow

- **Double brackets:** Use `[[ ... ]]` over `[ ... ]` or `test`.
- **Arithmetic:** Use `(( ... ))` for numeric comparisons.
- **No piping to while:** Use process substitution or `readarray`
  instead.

```bash
## Bad: variables set in while are lost
cat file | while read -r line; do ...

## Good: use process substitution
while read -r line; do
  process "${line}"
done < <(cat file)
```

### Functions

- **main function:** Scripts with multiple functions should define
  a `main()` function called at the end.
- **Local variables:** Always declare variables with `local` inside functions.

```bash
main() {
  local input="$1"
  validate "${input}"
  process "${input}"
}

main "$@"
```

### Error Handling

- **Errors to STDERR:** Error messages must go to STDERR using
  `>&2`.
- **Check return values:** Verify command success using `if` or `$?`.
- **PIPESTATUS:** For pipelines, check `PIPESTATUS` array
  immediately after execution.
- **Exit traps:** Use `trap` for cleanup on exit or error.

```bash
log() { echo "[$(basename "$0")] $*" >&2; }

cleanup() {
  rm -f "${tmpfile:-}"
}
trap cleanup EXIT
```

### Disallowed

- **eval:** Never use. Creates security vulnerabilities.
- **Backticks:** Use `$(...)` instead.
- **Aliases in scripts:** Use functions instead.
- **let and expr:** Use `$(( ... ))` or `(( ... ))` for
  arithmetic.

### Patterns

- **Self-documenting help:** Use `#/` comments for help text
  extracted with `grep`.

```bash
##!/bin/bash
##/ Usage: script.sh [options]
##/   -h, --help    Show this help

usage() { grep '^#/' "$0" | cut -c4-; exit 0; }
[[ "${1:-}" =~ ^(-h|--help)$ ]] && usage
```

## SQL

### Tooling

| Purpose | Tool              |
| ------- | ----------------- |
| Lint    | `sqlfluff lint`   |
| Format  | `sqlfluff format` |

### General Best Practices

- **Readability over brevity:** Optimise for readability,
  maintainability, and robustness rather than fewer lines.
  Newlines are cheap; people's time is expensive.
- **Query size:** Avoid enormous `select` statements.
  Refactor into multiple smaller CTEs that are later joined
  back together.
- **Identifiers:** Use lowercase `snake_case` for aliases
  and CTE names. Never use reserved words as identifiers.

### Syntax

- **Keywords:** Use lowercase for all keywords and function
  names (`select`, `from`, `count`).
- **Inequality:** Use `!=` instead of `<>` (reads like
  "not equal").
- **Concatenation:** Use `||` instead of `concat` (standard
  SQL, more portable).
- **Null handling:** Use `coalesce` instead of
  `ifnull`/`nvl`. Use `is null`/`is not null` instead of
  `isnull`/`notnull`.
- **Conditionals:** Use `case` statements instead of
  `iff`/`if` for portability.
- **Aliasing:** Always use the `as` keyword when aliasing
  columns, expressions, and tables.
- **Aggregates:** Always alias grouping aggregates and other
  column expressions.
- **Filtering:** Use `where` instead of `having` when either
  would suffice (better performance).
- **Unions:** Use `union all` instead of `union` unless
  duplicates must be removed.
- **Distinct:** Use `select distinct` instead of grouping by
  all columns to make intent clear.
- **Ordering:** Avoid `order by` unless necessary for
  correct results; let consumers sort if needed.
- **Date parts:** Specify date parts as strings, not
  keywords (`date_trunc('month', created_at)`).
- **Comments:** Always use `/* */` syntax. For multi-line,
  keep `/*` with first text and `*/` with last text, indent
  continuation lines by 4 spaces.
- **Strings:** Use single quotes. Double quotes are for
  identifiers in most dialects.

### Joins

- **No using:** Don't use `using` in joins; use `on` for
  consistency and flexibility.
- **Explicit joins:** Use `inner join` instead of just
  `join`.
- **Join order:** In join conditions, put the table
  referenced first immediately after `on` to clarify
  fan-out potential.
- **Column prefixes:** When joining multiple tables, always
  prefix column names with the table name/alias.
- **Filter placement:** For inner joins, put filter
  conditions in `where`, not the `join` clause.

```sql
/* Good */
select
    customers.email
    , orders.invoice_number
from customers
inner join orders on customers.id = orders.customer_id
where orders.total_amount >= 100

/* Bad */
select email, invoice_number
from customers
join orders on customers.id = orders.customer_id
    and orders.total_amount >= 100
```

### Performance

The below applies to OLAP engines (BigQuery, Databricks,
Spark, Snowflake):

#### Partitioning

- **Filter on partition columns:** Always include partition
  columns in `where` to avoid full table scans.
- **Use simple predicates:** Partition pruning works with
  `=`, `in`, `between`, `<`, `>`. Avoid functions on
  partition columns.
- **Filter early:** Place partition filters in the earliest
  CTE that references the table.
- BigQuery: Date/timestamp or integer range columns. Max
  4,000 partitions per table.
- Spark: Use `partitionBy()` when writing. Filter columns
  benefit most.
- Databricks: Delta Lake uses `partitionBy()`. Avoid
  over-partitioning; target files of 1GB each.
- Snowflake: Automatic micro-partitions. Define clustering
  keys to guide organisation.

#### Clustering

- **Filter on cluster columns:** Clustered columns enable
  block/micro-partition pruning.
- **Column order matters:** Filter on cluster columns in
  their defined order (leftmost first).
- BigQuery: Up to 4 columns. Effective on
  tables/partitions over 64MB.
- Spark: Use `bucketBy()` for similar benefits on
  join/filter columns.
- Databricks: Use `OPTIMIZE ... ZORDER BY` for
  multi-dimensional clustering. Liquid clustering
  (`CLUSTER BY`) auto-maintains.
- Snowflake: Up to 4 columns recommended. Check depth with
  `SYSTEM$CLUSTERING_INFORMATION`.

#### Join Strategies (Distributed Engines)

- **Broadcast joins:** Small table replicated to all nodes.
  Avoids shuffle. Best under 10MB (Spark default threshold).
- **Shuffle/hash joins:** Both sides redistributed by join
  key. Required for large-large joins.
- **Sort-merge joins:** Both sides sorted, then merged.
  Efficient when pre-sorted.
- **Collocated joins:** Tables partitioned on join key can
  join locally without shuffle.
- **Avoid skew:** Highly skewed join keys cause hot spots.
  Consider pre-aggregating or salting.
- Spark: `/*+ BROADCAST(t) */`, `/*+ MERGE(t) */`,
  `/*+ SHUFFLE_HASH(t) */`. Priority:
  broadcast > merge > shuffle_hash.
- Databricks: Same Spark hints. Adaptive Query Execution
  (AQE) auto-optimises join strategy at runtime.
- Snowflake: No hints. Ensure join columns have matching
  data types.

```sql
/* Spark: broadcast small dimension table */
select /*+ BROADCAST(regions) */
    orders.id
    , regions.name
from orders
inner join regions on orders.region_id = regions.id
```

### CTEs

- **Single purpose:** CTEs should perform a single, logical
  unit of work.
- **Naming:** Use verbose names that convey purpose. Don't
  prefix/suffix with `cte`.
- **Documentation:** Comment CTEs with confusing or notable
  logic.
- **Prefer CTEs:** Use CTEs rather than subqueries for
  readability and reusability.

```sql
/* Good */
with
    paying_customers as (
        select *
        from customers
        where plan_name != 'free'
    )

select ...
from paying_customers

/* Bad */
select ...
from (
    select * from customers where plan_name != 'free'
) as paying_customers
```

### Naming

- **Primary keys:** Name single-column primary keys `id`
  for clarity in joins.
- **Dates (UTC):** `<event>_date` for dates, `<event>_at`
  for timestamps.
- **Dates (timezone):** Suffix with timezone indicator
  (`order_date_et`, `created_at_pt`).
- **Booleans:** Prefix with verb (`is_`, `was_`, `has_`,
  `had_`, `does_`, `did_`).
- **Units:** Suffix numeric columns with units (`price_usd`,
  `weight_kg`).
- **Aliases:** Avoid unnecessary aliases, especially
  initialisms. Don't alias tables with 3 words or fewer.

```sql
/* Good */
select
    customers.email
    , orders.invoice_number
from customers
inner join orders on customers.id = orders.customer_id

/* Bad */
select c.email, o.invoice_number
from customers as c
inner join orders as o on c.id = o.customer_id
```

### Formatting

The overarching pattern: if there's only one thing, put it on
the same line as the keyword. If multiple, put each on its own
line indented one level.

- **Alignment:** Left-align everything.
- **Indentation:** Use 4 spaces.
- **Operators:** Never end a line with `and`, `or`, `+`,
  `||`, etc. Put operators at the start of continuation
  lines.
- **Commas:** Use leading commas on continuation lines,
  followed by a space.

#### Select Clause

```sql
/* Single column */
select id

/* Multiple columns */
select
    id
    , email

/* With distinct */
select distinct
    state
    , country
```

#### From Clause

```sql
/* Single join condition */
from customers
left join orders on customers.id = orders.customer_id

/* Multiple join conditions */
from customers
left join orders on
    customers.id = orders.customer_id
    and customers.region_id = orders.region_id
```

#### Where Clause

```sql
/* Single condition */
where email like '%@domain.com'

/* Multiple conditions */
where
    email like '%@domain.com'
    and plan_name != 'free'
```

#### Group By and Order By

```sql
/* Column numbers on one line */
/* Prefer column names over numbers */
group by 1, 2, 3

/* Column names: single on same line, multiple indented */
order by
    plan_name
    , signup_month
```

#### CTE Formatting

```sql
with
    paying_customers as (
        select ...
        from customers
    )

    , paying_customers_per_month as (
        /* CTE comments go here */
        select ...
        from paying_customers
    )

select ...
from paying_customers_per_month
```

#### Case Statements

- Single `when` on one line if short enough.
- Multi-line: indent `when`/`else` one level, `end` at same
  level as `case`.
- If after leading comma, align `end` with `case` using two
  extra spaces.

```sql
/* Short form */
select
    case when status_code = 1 then 'Active' else 'Inactive' end as status

/* Long form */
select
    case
        when status_code = 1 then 'Active'
        else 'Inactive'
    end as status
    , case
          when status_code = 1
              and deleted_at is null
              then 'Active'
          else 'Inactive'
      end as detailed_status
```

#### Window Functions

```sql
/* Short form */
row_number() over (partition by customer_id order by created_at) as order_rank

/* Long form */
row_number() over (
    partition by customer_id
    order by created_at
  ) as order_rank
```

#### In Lists

```sql
/* Break long lists */
where email in (
    'user-1@example.com'
    , 'user-2@example.com'
    , 'user-3@example.com'
)
```

#### Parentheses

- Don't put extra spaces inside parentheses.

```sql
/* Good */
where plan_name in ('monthly', 'yearly')

/* Bad */
where plan_name in ( 'monthly', 'yearly' )
```

## Terraform

### Tooling

| Purpose  | Tool                                                |
| -------- | --------------------------------------------------- |
| Format   | `terraform fmt` · `terragrunt hclfmt`               |
| Validate | `terraform validate` · `terragrunt validate-inputs` |
| Lint     | `tflint`                                            |
| Security | `checkov` or `trivy`                                |
| Docs     | `terraform-docs`                                    |

Infrastructure as Code using Terraform/OpenTofu, orchestrated
with Terragrunt.

### Repository Structure

Separate modules from live (deployment) repos. Choose between
traditional or stacks-based organisation.

#### Traditional Structure

Individual `terragrunt.hcl` files per resource, organised by
account/project and region:

```text
infrastructure-live/
├── terragrunt.hcl              # Root config (providers, state)
├── _common/                    # Shared templates
├── _modules/                   # Local modules (or use external)
├── <account>/                  # AWS: account, GCP: project
│   ├── account.hcl             # Account/project-level vars
│   ├── _global/                # Account-wide resources
│   └── <region>/
│       ├── region.hcl
│       └── <resource>/
│           └── terragrunt.hcl  # Hand-written config
```

#### Stacks Structure

`terragrunt.stack.hcl` files that reference a units catalogue and
generate configs:

```text
infrastructure-live/
├── terragrunt.hcl              # Root config (providers, state)
├── catalog/                    # Units catalog (or external git repo)
│   └── units/
│       ├── vpc/
│       │   └── terragrunt.hcl
│       └── rds/
│           └── terragrunt.hcl
├── <account>/
│   └── <region>/
│       └── terragrunt.stack.hcl   # Defines which units to deploy
```

Run `terragrunt stack generate` to create the actual
`terragrunt.hcl` files (by default in `.terragrunt-stack/`, or
in-place with `no_dot_terragrunt_stack = true`).

#### Conventions

- Prefix non-deployable folders with `_`
- Right-size modules: group resources that deploy together and
  share ownership
- State paths mirror folder structure
- Use three-part naming for module repositories:
  `terraform-<PROVIDER>-<NAME>`

### Variable Hierarchy

Load variables at appropriate levels using
`find_in_parent_folders()`:

```hcl
locals {
  account_vars = read_terragrunt_config(find_in_parent_folders("account.hcl"))
  region_vars  = read_terragrunt_config(find_in_parent_folders("region.hcl"))
}
```

### Include Patterns

Use double-include for DRY resource configs:

```hcl
include "root" {
  path = find_in_parent_folders()
}

include "common" {
  path   = "${dirname(find_in_parent_folders())}/_common/vpc.hcl"
  expose = true
}

terraform {
  source = "${include.common.locals.source_base_url}"
}

inputs = { name = "my-vpc" }
```

### Provider and State Generation

Define once in root using `generate` blocks:

```hcl
generate "provider" {
  path      = "provider.tf"
  if_exists = "overwrite_terragrunt"
  contents  = <<EOF
provider "aws" {
  region = "${local.region_vars.locals.aws_region}"
}
EOF
}

remote_state {
  backend = "s3"  # or "gcs" for GCP
  config = {
    bucket = "${local.account_vars.locals.account_name}-tfstate"
    key    = "${path_relative_to_include()}/terraform.tfstate"
  }
}
```

### Dependencies

```hcl
dependency "vpc" {
  config_path = "../vpc"
  mock_outputs = { vpc_id = "vpc-mock" }
  mock_outputs_allowed_terraform_commands = ["validate", "plan"]
}

inputs = { vpc_id = dependency.vpc.outputs.vpc_id }
```

### Stacks

**When to use:**

- `unit` blocks: Single infrastructure components (VPC, database)
- `stack` blocks: Reusable patterns of components to provision together

```hcl
## terragrunt.stack.hcl
locals {
  units_path = find_in_parent_folders("catalog/units")
}

unit "vpc" {
  source = "git::git@github.com:acme/infra-catalog.git//units/vpc?ref=v1.0.0"
  path   = "vpc"
  values = {
    name = "prod-vpc"
    cidr = "10.0.0.0/16"
  }
}

unit "database" {
  source = "${local.units_path}/rds"
  path   = "database"
  values = { vpc_name = "prod-vpc" }
}
```

Commands:

- `terragrunt stack generate` to generate stack structure
- `terragrunt stack generate --filter 'prod/**'` to filter by path
- `terragrunt run --all plan` to plan all generated units

### Terraform HCL Style

The following applies to all `.tf` files, whether hand-written or
in modules.

#### Code Formatting

- Place arguments at the top of blocks, followed by nested blocks
  with one blank line separation
- Put meta-arguments (count, for_each) first, followed by other
  arguments, then nested blocks
- Place lifecycle blocks last, separated by blank lines
- Separate top-level blocks with one blank line

#### Resource Organisation

- Define data sources before the resources that reference them
- Group related resources together (networking, compute, storage)
- Order resource parameters: meta-arguments, resource-specific
  parameters, nested blocks, lifecycle, depends_on

#### Resource Naming

- Use descriptive nouns separated by underscores
- Do not include the resource type in the resource name
- Example: `resource "aws_instance" "web_server" {}` not
  `resource "aws_instance" "webserver_instance" {}`

#### Variables and Outputs

- Define `type` and `description` for every variable
- Include reasonable `default` values for optional variables
- Set `sensitive = true` for passwords and private keys
- Order variable parameters: type, description, default,
  sensitive, validation blocks
- Order output parameters: description, value, sensitive
- Use descriptive names with underscores

#### Comments

- Use `#` for comments (not `//` or `/* */`)
- Write self-documenting code; use comments only to clarify
  complexity
- Add comments above resource blocks to explain non-obvious
  business logic

#### Local Values

- Use local values sparingly to avoid making code harder to
  understand
- Define in `locals.tf` if referenced across multiple files
- Define at the top of a file if specific to that file only

#### Dynamic Resource Management

- Use `count` for nearly identical resources
- Use `for_each` when resources need distinct values that cannot
  be derived from integers
- Use `count` with conditional expressions:
  `count = var.enable_feature ? 1 : 0`

#### Provider Configuration

- Always include a default provider configuration
- Define all providers in the same file (`providers.tf`)
- Define the default provider first, then aliased providers
- Use `alias` as the first parameter in non-default provider
  blocks

#### Version Management

- Pin Terraform version using `required_version` in terraform
  block
- Pin provider versions using exact versions in
  `required_providers`
- Pin module versions when sourcing from registries
- Prefer the pessimistic constraint operator (`~>`) for modules
  and providers
- Avoid open-ended constraints (`>`, `>=` without upper bound) in
  production

#### Security and Secrets

- Never commit `terraform.tfstate` files or `.terraform`
  directories
- Use dynamic provider credentials when possible
- Access secrets from external secret management systems
- Use environment variables for provider credentials

#### Testing and Validation

- Write Terraform tests for modules using the test
  framework
- Use variable validation blocks for restrictive requirements
- Include input validation with meaningful error messages

### Terraform Modules

When creating reusable Terraform modules (not Terragrunt
units):

#### Module Structure

```text
terraform-<provider>-<name>/
├── README.md
├── main.tf
├── variables.tf
├── outputs.tf
├── providers.tf
├── locals.tf
└── modules/
    └── <nested>/
```

#### Required Files

- `main.tf`: Primary resource and data source definitions
- `variables.tf`: Input variable definitions (alphabetical order)
- `outputs.tf`: Output value definitions (alphabetical order)
- `README.md`: Module purpose, usage, and examples

#### Guidance

- Keep modules focused on single infrastructure concerns
- Split large configurations into logical files
  (e.g., `network.tf`, `compute.tf`)
- Include `README.md` for external-facing nested modules; omit
  for internal-only

## TypeScript

### Tooling

| Purpose | Tool                                |
| ------- | ----------------------------------- |
| Lint    | `oxlint`                            |
| Format  | `oxfmt` (fallback: `biome format`)  |
| Types   | `tsc --noEmit`                      |
| Tests   | Per project (`vitest`, `pnpm test`) |

If npm or pnpm scripts are configured, check with the user
first.

### General Best Practices

- **Modern browsers:** Assume modern browser support
  unless otherwise specified. Skip polyfills for
  ES2020+ features.
- **Immutability:** Favour `readonly`, `as const`, and
  immutable patterns. Avoid mutation where practical.
- **Pure functions:** Prefer functions without side
  effects. Isolate side effects at boundaries.
- **Composition over inheritance:** Favour small
  composable functions and interfaces over class
  hierarchies.
- **Simplicity:** Avoid clever abstractions. Repetition
  is often cheaper than the wrong abstraction.
- **Explicit over implicit:** Be explicit about types at
  boundaries, nullability, and error conditions.

### Imports & Exports

- **Named exports only:** Avoid default exports to
  prevent ambiguity and improve refactoring.
- **Import style:** Use named imports for
  frequently-used symbols. Use namespace imports
  (`import * as foo`) for large APIs.
- **Type imports:** Use `import type` and `export type`
  for type-only references.
- **Relative paths:** Prefer relative imports within
  projects. Limit parent traversal depth
  (`../../../` is a smell).
- **No namespaces:** Use ES6 modules exclusively.
  TypeScript `namespace` is disallowed.
- **Export visibility:** Only export symbols used outside
  the module.
- **No mutable exports:** Use getter functions if
  external code needs dynamic values.

### Naming

- **UpperCamelCase:** Classes, interfaces, types, enums,
  decorators, type parameters.
- **lowerCamelCase:** Variables, parameters, functions,
  methods, properties, module aliases.
- **CONSTANT_CASE:** Global constants, enum values.
- **No decoration:** Don't encode type info in names. No
  `IMyInterface`, no Hungarian notation, no trailing
  underscores.
- **Acronyms as words:** `loadHttpUrl` not
  `loadHTTPURL`. Treat acronyms as single words.
- **Descriptive names:** Avoid abbreviations unfamiliar
  to external readers. Short names OK for variables in
  scope under 10 lines.

### Variables

- **const by default:** Use `const` unless reassignment
  is required, then use `let`.
- **Never var:** `var` is disallowed.
- **One per declaration:** Declare one variable per
  statement.

### Arrays

- **Literal syntax:** Use `[]` not `Array()` constructor.
- **Simple types:** Use `T[]` or `readonly T[]` for
  simple element types.
- **Complex types:** Use `Array<T>` when element type is
  complex.
- **No sparse arrays:** Don't set non-numeric properties
  on arrays.
- **Spread for iterables:** Use spread syntax for copying
  or concatenating arrays.

### Objects

- **Literal syntax:** Use `{}` not `Object()` constructor.
- **No for-in:** Use `Object.keys()`,
  `Object.values()`, `Object.entries()`, or `for...of`
  instead.
- **Destructuring:** Keep parameter destructuring simple
  (single level, unquoted properties).
- **Prefer Map/Set:** Use `Map` and `Set` over
  object-based dictionaries when keys are dynamic.

### Classes

- **Visibility:** Minimise exposure. Omit `public`
  modifier (it's the default). Use `private` or
  `protected` explicitly.
- **readonly:** Mark properties never reassigned outside
  constructor.
- **Parameter properties:** Use constructor parameter
  properties to reduce boilerplate.
- **Field initializers:** Initialise members at
  declaration when possible.
- **No private fields:** Use TypeScript `private`
  modifier, not `#ident` syntax.
- **Getters must be pure:** No side effects in getters.
  Don't define pass-through accessors.
- **No prototype manipulation:** Only framework code may
  touch prototypes.

### Functions

- **Function declarations:** Prefer `function foo()`
  over `const foo = () =>` for named functions.
- **Arrow functions:** Use in method bodies for `this`
  access, callbacks, and inline functions.
- **Concise arrow bodies:** Use for expressions that
  return values. Use block bodies for side effects.
- **Rest parameters:** Use instead of `arguments` object.
- **No this rebinding:** Don't use `.bind()`, `.call()`,
  `.apply()` to rebind `this`. Use arrow functions.

### Control Flow

- **Always brace:** Use braced blocks even for single
  statements.
- **for-of over for-in:** Prefer `for...of` for
  iteration. If using `for...in`, check
  `hasOwnProperty`.
- **Strict equality:** Always use `===` and `!==`.
  Exception: `== null` to match both `null` and
  `undefined`.
- **Switch default:** All switch statements require a
  `default` case (place last).
- **No fall-through:** Each case must terminate. Empty
  cases may fall through.

### Error Handling

- **Throw Error objects:** Always `throw new Error()`,
  never throw primitives.
- **Catch as Error:** Assume caught values are `Error`
  type. Add comments for non-Error throws.
- **Empty catch:** Only with explanatory comment.

### Type System

- **Inference:** Rely on inference for trivially inferred
  types (literals, `new` expressions).
- **Explicit generics:** Specify type parameters when
  initialising empty collections.
- **Interfaces over type aliases:** Prefer `interface`
  for object types. Use `type` for unions,
  intersections, mapped types.
- **Optional fields:** Use `?` syntax, not
  `| undefined`.
- **No null in aliases:** Never include `| null` or
  `| undefined` in type alias definitions. Add at
  usage.
- **unknown over any:** Use `unknown` for truly unknown
  types. Narrow with type guards before use.
- **Tuple types:** Prefer tuples over Pair-style
  interfaces. Consider inline object literals for 2-3
  properties.

### Type Assertions

- **Avoid assertions:** Prefer runtime checks or proper
  typing.
- **as syntax:** When necessary, use `as` (not angle
  brackets).
- **Double assertions:** Use `as unknown as Type` when
  required.
- **Object literals:** Use type annotations (`:`) not
  assertions (`as`).
- **Non-null assertions:** Avoid `!`. Prefer explicit
  null checks.

### Strings

- **Template literals:** Use for interpolation,
  multi-line strings, or complex concatenation. Not for
  simple static strings.
- **No line continuations:** Don't use backslash at line
  end.

### Type Coercion

- **String():** Use `String(x)` or template literals,
  not `'' + x`.
- **Boolean():** Use explicit comparison for enums.
  Implicit coercion OK for other types in conditionals.
- **Number():** Use `Number(x)` with `isFinite()` check.
  Avoid `parseInt`/`parseFloat` unless parsing
  non-base-10.

### Comments

- **JSDoc for documentation:** Use `/** */` for
  user-facing documentation.
- **Line comments for implementation:** Use `//` for
  implementation notes.
- **No block comments:** Use multiple `//` lines,
  not `/* */`.
- **Markdown in JSDoc:** Write JSDoc content in Markdown.

### tsconfig.json Strictness

When creating new TypeScript projects, enable these compiler
options:

```json
{
  "compilerOptions": {
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,
    "verbatimModuleSyntax": true,
    "isolatedModules": true
  }
}
```

### Disallowed

- **Wrapper objects:** Never use `String`, `Boolean`,
  `Number`, `Object` constructors.
- **const enum:** Use plain `enum` instead.
- **debugger:** Not in production code.
- **with:** Never use.
- **eval:** No dynamic code evaluation.
- **@ts-ignore:** Use proper typing instead.
  `@ts-expect-error` only in tests with explanation.
- **Modifying builtins:** Never extend or modify
  built-in prototypes.
