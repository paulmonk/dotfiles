<!-- Generated by: just coding-agents -->
<!-- Source: claude/CLAUDE.md + claude/rules/*.md -->
<!-- Do not edit directly -->

# Agent Profile

**Purpose**: Operate tasks in this repo while honouring user
preferences and house style.
**Read When**: On task initialisation and before major decisions;
re-skim when requirements shift.
**Concurrency**: Assume other agents or the user might land commits
mid-run; refresh context before summarising or editing.

## Quick Obligations

| Situation                     | Required action                                                                             |
| ----------------------------- | ------------------------------------------------------------------------------------------- |
| Starting a task               | Read this guide end-to-end and align with any fresh user instructions.                      |
| Relevant learnings exist      | Check `.claude/learnings/` and `~/.claude/learnings/` for past solutions to similar issues. |
| Tool or command hangs         | If a command runs longer than 5 minutes, stop it, capture logs, and check with the user.    |
| Reviewing git status or diffs | Treat them as read-only context; never revert or assume missing changes were yours.         |
| Adding a dependency           | Research well-maintained options and confirm fit with the user before adding.               |

## Mindset & Process

- **No breadcrumbs**. If you delete or move code, do not leave a
  comment in the old place. No "// moved to X", no "relocated".
  Just remove it.
- **Think hard, do not lose the plot**. Instead of applying a
  bandaid, fix things from first principles. Find the source and
  fix it versus applying a cheap bandaid on top.
- When taking on new work, follow this order:
  1. Think about the architecture.
  2. Research official docs, blogs, or papers on the best architecture.
  3. Review the existing codebase.
  4. Compare the research with the codebase to choose the best fit.
  5. Implement the fix or ask about the tradeoffs the user is
     willing to make.
- Write idiomatic, simple, maintainable code. Always ask yourself
  if this is the most simple intuitive solution to the problem.
- Follow the scout method: Leave each repo better than how you
  found it. If something is giving a code smell, fix it for the
  next person.
- Clean up unused code ruthlessly. If a function no longer needs a
  parameter or a helper is dead, delete it and update the callers
  instead of letting the junk linger.
- **Search before pivoting**. If you are stuck or uncertain, do a
  quick web search for official docs or specs, then continue with
  the current approach. Do not change direction unless asked.
- If code is very confusing or hard to understand:
  1. Try to simplify it.
  2. Add an ASCII art diagram in a code comment if it would help.
  3. Add a Mermaid diagram for documentation if it would help.

## Tool Preferences

- **Web scraping**: Use **firecrawl** MCP instead of `curl`,
  `wget`, or built-in web fetch. Firecrawl handles
  JavaScript-rendered pages and returns cleaner markdown.
- **Web search**: Use **exa** MCP instead of built-in web search.
  Exa provides more relevant results, better content extraction,
  and domain filtering options.
- **Library docs**: Use **context7** MCP for up-to-date library
  documentation and code examples. Prefer it over web search when
  looking up API references.
- **File search**: Use `fd` instead of `find`. fd is faster,
  respects `.gitignore`, and has simpler syntax.
- **Text search**: Use `rg` (ripgrep) instead of `grep`. For
  AST-aware code searches use `ast-grep`, for semantic analysis
  use `semgrep`.
- **File deletion**: Use `trash` instead of `rm`. Trash moves
  files to the system trash where they can be recovered.

## Tooling & Workflow

- **Task runner preference**. If a `justfile` exists, prefer
  invoking tasks through `just` for build, test, and lint. Do not
  add a `justfile` unless asked. If no `justfile` exists and there
  is a `Makefile` you can use that. Default lint/test commands if
  no `Makefile` or `justfile` exists are in each specific
  language's rules file.
- **AST-first where it helps**. Prefer `ast-grep` for tree-safe
  edits when it is better than regex.
- **Git safety**: Do not run destructive git commands
  (`reset --hard`, `checkout .`, `clean -f`, `push --force`)
  without explicit permission. Commits via `/commit` are fine.
- **Git worktrees**: Create worktrees in `.worktrees/` at the
  repository root
  (e.g., `git worktree add -b feature-x .worktrees/feature-x`).

### Code Commit Message Style

- Use [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/):
- Format: `<type>(<scope>): <description>` with optional body and footer
- Types: `feat`, `fix`, `refactor`, `docs`, `test`, `chore`
- Subject: lowercase after type, present tense, 50 chars or less
- Blank line between subject and body
- Body: wrap at 72 characters, explain the why not the what
- Examples:
  - `feat(agents): add support for App pattern with plugins`
  - `fix(sessions): prevent memory leak in session cleanup`
  - `refactor(tools): unify environment variable enabled checks`
- If you are ever curious how to run tests or what we test, read
  through `.github/workflows` or `.cloudbuild` or `.circleci`
  (depends on the repo). CI runs everything and it should behave
  the same locally.

## Code Testing Philosophy

- **Use real code over mocks.** Tests should use real
  implementations as much as possible. Only mock external
  dependencies like network calls, LLM APIs, or cloud services.
- **Test interface behaviour, not implementation details.** Tests
  should verify that the public API behaves correctly, not how
  it's implemented internally. This makes tests resilient to
  refactoring and ensures the contract with users remains intact.
- **Test requirements:**
  - Fast and isolated tests where possible.
  - Use real components; mock only external dependencies.
  - Focus on testing public interfaces and behaviour.
  - Descriptive test names that explain what behaviour is being
    tested.
  - High coverage for new features, edge cases, and error
    conditions.
- Unless the user asks otherwise, run only the tests you added or
  modified instead of the entire suite to avoid wasting time.

## Code Comments

- **Explain the why, not the what.**
- Well-written code should be largely self-documenting.
- Comments serve a different purpose: they should explain complex
  algorithms, non-obvious business logic, or the rationale behind
  a particular implementation choice.
- Avoid comments that merely restate what the code does
  (e.g., `# increment i` above `i += 1`).
- Comments should be written as complete sentences. Block comments
  must begin with a `#` followed by a single space.

## Code Dependencies & External APIs

- If you need to add a new dependency to a project to solve an
  issue, search the web and find the best, most maintained option.
  Something most other folks use with the best exposed API.
- We don't want to be in a situation where we are using an
  unmaintained dependency, that no one else relies on.

## Knowledge Base

For information on a specific topic or my workday (see daily notes)
within the Obsidian vault:

- Use **qmd** to search the vault.
- Notes in the vault are organised into the
  [PARA](https://fortelabs.com/blog/para/) system:
  - **Projects**: Short-term efforts with a specific goal and
    deadline, actively being worked on.
  - **Areas**: Ongoing responsibilities with no end date that
    require continuous attention.
  - **Resources**: Reference materials, notes, and information
    that support your projects and areas but are not actionable
    themselves.
  - **Archives**: Inactive items from the other three categories
    saved for future reference.

## Final Handoff

Before finishing a task:

1. Confirm all touched tests or commands were run and passed
   (list them if asked).
2. Summarise changes with file and line references.
3. Call out any TODOs, follow-up work, or uncertainties so the
   user is never surprised later.

## Self-Improvement Protocol

When the user corrects a mistake or provides feedback on how I
should work:

1. Apply the correction immediately.
2. Ask: "Should I add this to CLAUDE.md to prevent this mistake
   in future?"
3. If yes, propose a concise rule and update the appropriate
   section.

## Go

### Tooling

- Use `gofmt -w .` to format code
- Use `go vet ./...` to lint code for best practices
- Use `staticcheck ./...` (if available) to lint code
  for best practices
- Use `go test ./...` to test code

### General Best Practices

- Use the standard library where possible. Only pull in
  dependencies when they provide significant value.
- Design zero values to be useful; users should be able
  to use a type immediately after declaration.
- **Naming:** No `Get` prefix on getters (`Owner()` not
  `GetOwner()`). Single-method interfaces use method
  name + "-er" suffix (`Reader`, `Writer`).
- **Variable names:** Length proportional to scope. Short
  names (1-3 chars) in small scopes, descriptive names
  for exported identifiers and wider scopes.
- **Receiver names:** Keep short (1-2 letters),
  abbreviate the type name, apply consistently across
  all methods of a type.
- **Initialisms:** Maintain consistent casing (`URL`,
  `HTTP`, `ID` not `Url`, `Http`, `Id`). All caps for
  initialisms regardless of position.
- **Packages:** Name for what they provide, not generic
  terms like "util" or "helper". Consider how the call
  site reads.
- **Control flow:** Avoid unnecessary `else` when `if`
  ends with `return`/`break`/`continue`. Indent error
  handling before happy path.
- **Initialisation:** Use `if err := ...; err != nil` to
  scope variables tightly. Prefer `:=` for non-zero
  values, `var` for zero-value declarations.
- **Composite literals:** Use field labels
  (`Name: value`) for resilience to struct changes.
  Omit explicit zeros when zero values suffice.
- **Shadowing:** Avoid shadowing package names or outer
  variables. Use explicit assignment (`=`) instead of
  `:=` in nested scopes when reusing variables.
- **Defer:** Use for cleanup (close files, unlock
  mutexes). Args evaluate at defer time, not call time
  (common gotcha).
- **Generics:** Use `any` instead of `interface{}`.
  Prefer generic functions over type-specific variants
  when appropriate.

### Imports

- **Grouping order:** Standard library, then project
  packages, then third-party packages. Separate groups
  with blank lines.
- **Renaming:** Rename imports only to avoid collisions.
  Use names following package naming rules.
- **Dot imports:** Never use; impairs code clarity and
  grep-ability.
- **Blank imports:** Only in main packages or tests for
  side effects; avoid in libraries.

### Context

- **First parameter:** `context.Context` is always the
  first parameter, named `ctx`.
- **Never store in structs:** Pass context through
  function parameters, not struct fields.
- **Propagate cancellation:** Pass the context you
  receive to downstream calls; don't create new
  background contexts mid-call-chain.
- **Custom types:** Never create custom context key types
  that shadow the standard library.

### Data Structures

- **Slices:** Use `slices` package for common operations
  (`slices.Contains`, `slices.Sort`). Prefer `nil`
  slices over empty initialised slices in function
  signatures. Preallocate capacity only when final size
  is known empirically.
- **Maps:** Use comma-ok idiom to distinguish missing
  keys from zero values. Use `maps` package for
  operations like `maps.Clone`.
- **Embedding:** Promoted methods receive the inner type
  as receiver, not outer (can surprise you).

### Interfaces

- **Define where consumed:** Define interfaces in the
  package that uses them, not the package that
  implements them.
- **Compile-time compliance:** Verify with
  `var _ Interface = (*Type)(nil)`.
- **Channel direction:** Specify (`chan<-`, `<-chan`) to
  convey ownership and catch mistakes at compile time.
- **Accept/Return:** Accept interfaces, return concrete
  types (unless swapping implementations is expected).

### Types and Receivers

- **Pointer receivers:** Use for methods that mutate
  state, for large structs, or when in doubt.
- **Value receivers:** Use for small immutable types,
  basic types, or when the type is naturally a value
  (like `time.Time`).
- **Consistency:** All methods on a type should use the
  same receiver type when possible.
- **Pass values:** Avoid pointer parameters for small
  types; use pointers for large structs or when mutation
  is needed.
- **Copying:** Never copy structs containing
  `sync.Mutex`, `sync.WaitGroup`, or similar
  synchronisation primitives.

### Concurrency

- **Philosophy:** Share memory by communicating, not the
  other way around.
- **Goroutine lifetime:** Make lifetimes explicit. Use
  `context.Context` for cancellation or
  `sync.WaitGroup` to track completion. Never
  fire-and-forget.
- **Channels:** Unbuffered for synchronisation, buffered
  for throughput. Use `select` with `default` for
  non-blocking ops.
- **Patterns:** Buffered channel as semaphore; worker
  pool reading from shared channel; channel of channels
  for request/response.
- **Synchronous by default:** Prefer synchronous
  functions; let callers add concurrency. Don't force
  async on consumers.
- **Documentation:** Document mutating operations'
  thread-safety. Readers assume read-only ops are safe
  unless stated otherwise.

### Error Handling

- **Explicit handling:** Handle all errors explicitly. Do
  not use `_` to ignore errors unless there is a clear
  reason documented in a comment.
- **Errors over panics:** Prefer returning errors over
  panicking. Reserve `panic` for truly unrecoverable
  situations or API misuse (like reflect).
- **Return type:** Return `error` interface, not concrete
  error types, as the final return value.
- **Custom errors:** Create custom error types
  implementing `Error() string` for rich context
  (like `os.PathError`).
- **Error strings:** Lowercase, no trailing punctuation,
  identify origin (e.g.,
  `"mypackage: failed to open"`).
- **Wrapped errors:** Use `errors.Is()` for wrapped
  errors, simple `==` for sentinel values.
- **Adding context:** Add context without duplicating
  what the underlying error provides. Use `%w` to
  preserve error chain for programmatic inspection,
  `%v` to hide implementation details. Place `%w` at
  the end of format strings.
- **Logging:** Avoid duplicate logging; return errors and
  let callers decide whether to log. Prefer `log/slog`
  for structured logging.
- **Initialisation failures:** Use `log.Fatal` for
  initialisation failures, not `panic`. Internal
  panic-recover must never escape package boundaries.

### Documentation

- **Doc comments:** Required for all exported names.
  Start with the name being documented.
- **Complete sentences:** Use proper capitalisation and
  punctuation in doc comments.
- **Concurrency safety:** Document mutating operations
  that are not thread-safe. Readers assume read-only
  operations are safe for concurrent use.
- **Cleanup requirements:** Explicitly document when and
  how to clean up resources (Close, Stop, Cancel).
- **Examples:** Include runnable examples in `_test.go`
  files for complex APIs; they appear in godoc.

### Testing

- **No assertion libraries:** Use standard `if` checks
  and `t.Error`/`t.Fatal`. Use `cmp.Diff` from
  `github.com/google/go-cmp/cmp` for complex
  comparisons.
- **Failure messages:** Include function name, inputs,
  and "got vs want" in failure messages.
- **Table-driven tests:** Group related test cases in a
  slice of structs and loop over them. Use field names
  in literals for clarity.
- **Subtests:** Use `t.Run()` for grouped cases; enables
  selective test runs and parallel execution.
- **t.Error vs t.Fatal:** Use `t.Error` with `continue`
  for per-entry failures in table tests. Reserve
  `t.Fatal` for setup failures that prevent
  continuation.
- **Helpers:** Use `t.Helper()` in setup functions to
  correctly attribute failures.
- **Goroutines in tests:** Never call
  `t.Fatal`/`t.FailNow` from goroutines other than the
  test function; use `t.Error` and return.
- **Real transports:** Test with real HTTP/RPC transports
  connected to test-double backends rather than
  hand-implementing clients.

### Cryptography

- **Random numbers:** Use `crypto/rand` for
  security-sensitive randomness, never `math/rand`.

## Issue Tracking with Beads

When a project uses **beads** (`bd`), use it for tracking work
across sessions. Run `bd prime` for full workflow context or
`bd hooks install` for auto-injection.

| Command                                      | Purpose                                   |
| -------------------------------------------- | ----------------------------------------- |
| `bd ready`                                   | Find unblocked work ready to start        |
| `bd show <id>`                               | View issue details                        |
| `bd create "Title" --type task --priority 2` | Create a new issue                        |
| `bd update <id> --status in_progress`        | Mark work as started                      |
| `bd close <id>`                              | Complete and close an issue               |
| `bd sync`                                    | Sync with git remote (run at session end) |

Issue types: `task`, `bug`, `story`, `epic`, `spike`.
Priority: 1 (highest) to 4 (lowest).

## Python

### Tooling

- Use `uv` and `pyproject.toml` in all Python repos.
  Prefer `uv sync` for env and dependency resolution.
  Do not introduce `pip` venvs, Poetry, or
  `requirements.txt` unless asked.
- Use `uv run ruff check` for linting/formatting.
- Use `uv run ty` for type checking, if unavailable use
  `uv run mypy` instead.
- Use `build-backend = "uv_build"` for the backend when
  building python packages.

### General Best Practices

- **Constants:** Use immutable global constant
  collections (tuple, frozenset). Prefer constants over
  string/int literals, especially for dictionary keys,
  pathnames, and enums. Use `ALL_CAPS` naming.
- **Mutable globals:** Avoid mutable global state. If
  needed, declare at module level and treat as internal.
- **Comprehensions:** Use list, set, and dict
  comprehensions for simple cases. Avoid multiple `for`
  clauses or complex filter expressions; use loops
  instead.
- **Iteration:** Iterate directly over containers. Use
  `enumerate()` for indices, `dict.items()` for
  keys/values, `zip()` for parallel iteration.
- **Built-ins:** Leverage `all()`, `any()`,
  `reversed()`, `sum()`,
  `itertools.chain.from_iterable()` for flattening.
- **Generators:** Use for memory efficiency with large
  sequences. Document with `Yields:` section in
  docstrings.
- **Lambdas:** Use only for one-liners. Prefer generator
  expressions over `map()` or `filter()` with lambdas.
- **Decorators:** Use for cross-cutting concerns
  (logging, timing, caching). Use `functools.wraps()`
  to preserve metadata. Avoid `@staticmethod`; limit
  `@classmethod`.
- **Context managers:** Use `with` statements for
  resource management (files, locks, connections).
- **Single assignment:** Prefer single-assignment over
  assign-and-mutate. Use conditional expressions for
  simple cases.
- **Truthiness:** Use implicit false (`if not items:`)
  but always use explicit `if foo is None` to
  distinguish from other falsy values.
- **Default arguments:** NEVER use mutable default
  arguments. Use `None` as sentinel.
- **Properties:** Use `@property` for trivial
  computations. Avoid for expensive operations, side
  effects, or operations that can fail.
- **Modules for namespacing:** Use modules as primary
  namespacing mechanism, not classes. Avoid methods
  that don't use `self`.
- **Keyword-only by default:** Functions with more than
  one parameter should make all but the first
  keyword-only using `*`. Use `/` for positional-only
  when parameter names are implementation details.
  Dataclasses should also use `kw_only`.
- **Power features:** Avoid metaclasses, bytecode
  manipulation, and dynamic attribute access unless
  truly necessary.

### Imports

- **Style:** Use `import x` for packages and modules.
  Use `from x import y` only for typing,
  collections.abc, and specific items from large
  modules.
- **Grouping order:** Future imports, standard library,
  third-party packages, local imports. Separate groups
  with blank lines. Sort lexicographically within
  groups.
- **Full pathnames:** Always use absolute imports. Avoid
  relative imports except within package internals.
- **No wildcards:** Never use `from x import *`.
- **Datetime:** Use `import datetime as dt` rather than
  `from datetime import datetime`. Access via
  `dt.datetime`, `dt.timedelta`, etc.

### Naming

- **Conventions:** `module_name`, `package_name`,
  `ClassName`, `ExceptionName`, `CONSTANT_NAME`,
  `function_name`, `method_name`, `local_var_name`,
  `_private_name`.
- **Mappings:** Name like `value_by_key` to enhance
  readability (e.g., `item = item_by_id[id]`).
- **Avoid:** Single-character names except for iterators
  (`i`, `j`, `k`) and context managers (`f` for files).
  Avoid abbreviations unfamiliar to non-native
  speakers.
- **Protected/Private:** Use
  `_single_leading_underscore` for protected,
  `__double_leading_underscore` only to prevent
  subclass collisions.

### Type Annotations

- **Coverage:** Annotate public APIs and complex internal
  code.
- **Abstract types:** Use `collections.abc` (`Sequence`,
  `Mapping`, `Iterable`) over `typing` equivalents.
- **NewType:** Use `typing.NewType` to create distinct
  types from primitives for domain modelling.
- **Nullable:** Explicitly mark with `X | None`. Never
  leave implicit.
- **Forward references:** Use
  `from __future__ import annotations` or string quotes
  for forward declarations.
- **Aliases:** Create type aliases for complex types with
  `CapWord` names.
- **Containers:** Use `list[T]` for homogeneous
  sequences, `tuple[T, ...]` for variable-length,
  `tuple[T1, T2]` for fixed structure.
- **Final:** Always include the type parameter for
  constants: `Final[int]`, `Final[Path]`, not bare
  `Final`.

### Docstrings

- **Format:** Use triple double-quotes. First line is
  summary ending with period. Blank line before
  detailed description.
- **Functions/Methods:** Document parameters, return
  values, and exceptions using Args, Returns, and
  Raises sections.
- **Classes:** Describe what instances represent.
  Document public attributes in Attributes section.
- **Modules:** Start with description of contents and
  usage examples.

```python
def fetch_data(url: str, timeout: int = 30) -> dict[str, Any]:
    """Fetch JSON data from a URL.

    Args:
        url: The endpoint to fetch from.
        timeout: Request timeout in seconds.

    Returns:
        Parsed JSON response as a dictionary.

    Raises:
        RequestError: If the request fails or times out.
    """
```

### Threading

- **No atomicity assumptions:** Don't rely on built-in
  type atomicity. Use `queue` module or `threading`
  locks for thread-safe communication.
- **Prefer queues:** Use `queue.Queue` for
  producer-consumer patterns over shared mutable state.

### Main Guard

- **Always use:** Every executable script must have
  `if __name__ == '__main__':` guard.
- **Minimal code:** Keep code outside the guard minimal
  (imports, constants, definitions only).

```python
def main() -> None:
    ...

if __name__ == '__main__':
    main()
```

### Function Design

- **Length:** Prefer functions under 40 lines. Break
  longer functions into smaller, focused pieces.
- **Single responsibility:** Each function should do one
  thing well.
- **`__repr__()` vs `__str__()`:** Implement
  `__repr__()` for unambiguous, developer-focused
  strings. `__str__()` for human-readable output.

### Libraries and Tools

- **`collections.Counter`:** For efficiently counting
  hashable objects.
- **`collections.defaultdict`:** For avoiding key checks
  when initialising dictionary values.
- **`heapq`:** Use `nlargest()`, `nsmallest()`,
  `merge()` for efficient operations.
- **`attrs`/`dataclasses`:** Use for classes with
  auto-generated boilerplate methods.
- **Serialisation:** JSON for cross-language, `pydantic`
  for runtime validation, `cattrs` for performance with
  dataclasses/attrs.
- **Regular expressions:** Use `re.VERBOSE` for readable
  regexes. Compile regexes used multiple times. Avoid
  regexes for simple string checks.
- **Caching:** Use `functools.lru_cache` with care.
  Prefer immutable return types. Use
  `functools.cached_property` for methods.
- **Pickle:** Avoid due to security risks. Prefer JSON,
  Protocol Buffers, or msgpack.

### Testing

- **Function tests:** Use function-based pytest tests,
  not unittest classes.
- **Assertions:** Use pytest's native `assert` with
  informative expressions. Add custom messages when
  needed.
- **Parameterized tests:** Use
  `@pytest.mark.parametrize` to reduce duplication.
- **Fixtures:** Use pytest fixtures for setup, teardown,
  and dependency injection.
- **Mocking:** Use `mock.create_autospec()` with
  `spec_set=True`. Prefer injecting dependencies via
  fixtures over patching.
- **Temporary files:** Use pytest's `tmp_path` and
  `tmp_path_factory` fixtures.
- **Deterministic inputs:** Do not use random inputs in
  unit tests. Use deterministic, easy-to-reason-about
  inputs.
- **Test invariants:** Focus on invariant behaviours of
  public APIs, not implementation details.

### Error Handling

- **Bare except:** Never use bare `except:`. Always catch
  specific exceptions.
- **Scope:** Minimise try/except block scope. Only wrap
  the code that can raise.
- **Re-raising:** Use bare `raise` to preserve stack
  trace. Use `raise NewException from original` to
  chain. Use `raise NewException from None` to suppress
  context.
- **Messages:** Always include descriptive messages when
  raising.
- **Converting to strings:** `repr(e)` is often better
  than `str(e)`. Use `traceback` module for full
  details.
- **Returning None:** Be consistent. Use explicit
  `return None` if function can return values. Bare
  `return` only for `-> None` functions.

## Rust

### Tooling

- Use `cargo fmt` to format code
- Use `cargo clippy --all --benches --tests --examples --all-features`
  to lint code for best practices
- Use `cargo test` to test code

### General Best Practices

- Do NOT use unwraps or anything that can panic in Rust code,
  handle errors. Obviously in tests unwraps and panics are fine!
- Prefer `crate::` over `super::` for imports in non-test code.
  One-level `super::` in test modules is acceptable. If you see
  deep `super::super::` chains, refactor to use `crate::`.
- Avoid `pub use` on imports unless you are re-exposing a
  dependency so downstream consumers do not have to depend on it
  directly.
- Skip global state via `lazy_static!`, `Once`, or similar;
  prefer passing explicit context structs for any shared state.
- Prefer strong types over strings, use enums and newtypes when
  the domain is closed or needs validation.
- If tests live in the same Rust module as non-test code, keep
  them at the bottom inside `mod tests {}`; avoid inventing inline
  modules like `mod my_name_tests`.

## Shell

### Tooling

- Use `shellcheck` to lint code for best practices
- Use `shfmt -i 2` to format code

### General Best Practices

- **Small utilities only:** Limit shell to small utilities,
  wrapper scripts, and glue code under 100 lines.
- **Consider alternatives:** If performance matters, control flow
  is complex, or the script exceeds 100 lines, use Python, Go, or
  another language.
- **No SUID/SGID:** Never use SUID or SGID on shell scripts. Use
  `sudo` for elevated access.

### Script Setup

- **Shebang:** Always start with `#!/bin/bash` or
  `#!/usr/bin/env bash`.
- **Strict mode:** Enable
  `set -o errexit -o errtrace -o pipefail -o nounset`.
- **Header comment:** Every file needs a comment describing its
  purpose.
- **File order:** Shebang, header comment, `set` options,
  constants, includes/sources, functions, main logic.
- **Extensions:** Executables may omit `.sh`; libraries must use
  `.sh` and be non-executable.

### Variables & Naming

- **Brace syntax:** Prefer `"${var}"` over `"$var"` for clarity.
- **Arrays for lists:** Use arrays for storing lists and
  command-line arguments.
- **Functions:** Lowercase with underscores. Use `::` prefix for
  namespacing (e.g., `mylib::init`).
- **Variables:** Lowercase with underscores for local variables.
- **Constants:** UPPERCASE with underscores, declared at file top
  with `readonly` or `declare -r`.

### Control Flow

- **Double brackets:** Use `[[ ... ]]` over `[ ... ]` or `test`.
- **Arithmetic:** Use `(( ... ))` for numeric comparisons.
- **No piping to while:** Use process substitution or `readarray`
  instead.

```bash
## Bad: variables set in while are lost
cat file | while read -r line; do ...

## Good: use process substitution
while read -r line; do
  process "${line}"
done < <(cat file)
```

### Functions

- **main function:** Scripts with multiple functions should define
  a `main()` function called at the end.
- **Local variables:** Always declare variables with `local` inside functions.

```bash
main() {
  local input="$1"
  validate "${input}"
  process "${input}"
}

main "$@"
```

### Error Handling

- **Errors to STDERR:** Error messages must go to STDERR using
  `>&2`.
- **Check return values:** Verify command success using `if` or `$?`.
- **PIPESTATUS:** For pipelines, check `PIPESTATUS` array
  immediately after execution.
- **Exit traps:** Use `trap` for cleanup on exit or error.

```bash
log() { echo "[$(basename "$0")] $*" >&2; }

cleanup() {
  rm -f "${tmpfile:-}"
}
trap cleanup EXIT
```

### Disallowed

- **eval:** Never use. Creates security vulnerabilities.
- **Backticks:** Use `$(...)` instead.
- **Aliases in scripts:** Use functions instead.
- **let and expr:** Use `$(( ... ))` or `(( ... ))` for
  arithmetic.

### Patterns

- **Self-documenting help:** Use `#/` comments for help text
  extracted with `grep`.

```bash
##!/bin/bash
##/ Usage: script.sh [options]
##/   -h, --help    Show this help

usage() { grep '^#/' "$0" | cut -c4-; exit 0; }
[[ "${1:-}" =~ ^(-h|--help)$ ]] && usage
```

## SQL

### Tooling

- Use `sqlfluff lint` to lint code for best practices
- Use `sqlfluff format` to format code

### General Best Practices

- **Readability over brevity:** Optimise for readability,
  maintainability, and robustness rather than fewer lines.
  Newlines are cheap; people's time is expensive.
- **Query size:** Avoid enormous `select` statements.
  Refactor into multiple smaller CTEs that are later joined
  back together.
- **Identifiers:** Use lowercase `snake_case` for aliases
  and CTE names. Never use reserved words as identifiers.

### Syntax

- **Keywords:** Use lowercase for all keywords and function
  names (`select`, `from`, `count`).
- **Inequality:** Use `!=` instead of `<>` (reads like
  "not equal").
- **Concatenation:** Use `||` instead of `concat` (standard
  SQL, more portable).
- **Null handling:** Use `coalesce` instead of
  `ifnull`/`nvl`. Use `is null`/`is not null` instead of
  `isnull`/`notnull`.
- **Conditionals:** Use `case` statements instead of
  `iff`/`if` for portability.
- **Aliasing:** Always use the `as` keyword when aliasing
  columns, expressions, and tables.
- **Aggregates:** Always alias grouping aggregates and other
  column expressions.
- **Filtering:** Use `where` instead of `having` when either
  would suffice (better performance).
- **Unions:** Use `union all` instead of `union` unless
  duplicates must be removed.
- **Distinct:** Use `select distinct` instead of grouping by
  all columns to make intent clear.
- **Ordering:** Avoid `order by` unless necessary for
  correct results; let consumers sort if needed.
- **Date parts:** Specify date parts as strings, not
  keywords (`date_trunc('month', created_at)`).
- **Comments:** Always use `/* */` syntax. For multi-line,
  keep `/*` with first text and `*/` with last text, indent
  continuation lines by 4 spaces.
- **Strings:** Use single quotes. Double quotes are for
  identifiers in most dialects.

### Joins

- **No using:** Don't use `using` in joins; use `on` for
  consistency and flexibility.
- **Explicit joins:** Use `inner join` instead of just
  `join`.
- **Join order:** In join conditions, put the table
  referenced first immediately after `on` to clarify
  fan-out potential.
- **Column prefixes:** When joining multiple tables, always
  prefix column names with the table name/alias.
- **Filter placement:** For inner joins, put filter
  conditions in `where`, not the `join` clause.

```sql
/* Good */
select
    customers.email
    , orders.invoice_number
from customers
inner join orders on customers.id = orders.customer_id
where orders.total_amount >= 100

/* Bad */
select email, invoice_number
from customers
join orders on customers.id = orders.customer_id
    and orders.total_amount >= 100
```

### Performance

The below applies to OLAP engines (BigQuery, Databricks,
Spark, Snowflake):

#### Partitioning

- **Filter on partition columns:** Always include partition
  columns in `where` to avoid full table scans.
- **Use simple predicates:** Partition pruning works with
  `=`, `in`, `between`, `<`, `>`. Avoid functions on
  partition columns.
- **Filter early:** Place partition filters in the earliest
  CTE that references the table.
- BigQuery: Date/timestamp or integer range columns. Max
  4,000 partitions per table.
- Spark: Use `partitionBy()` when writing. Filter columns
  benefit most.
- Databricks: Delta Lake uses `partitionBy()`. Avoid
  over-partitioning; target files of 1GB each.
- Snowflake: Automatic micro-partitions. Define clustering
  keys to guide organisation.

#### Clustering

- **Filter on cluster columns:** Clustered columns enable
  block/micro-partition pruning.
- **Column order matters:** Filter on cluster columns in
  their defined order (leftmost first).
- BigQuery: Up to 4 columns. Effective on
  tables/partitions over 64MB.
- Spark: Use `bucketBy()` for similar benefits on
  join/filter columns.
- Databricks: Use `OPTIMIZE ... ZORDER BY` for
  multi-dimensional clustering. Liquid clustering
  (`CLUSTER BY`) auto-maintains.
- Snowflake: Up to 4 columns recommended. Check depth with
  `SYSTEM$CLUSTERING_INFORMATION`.

#### Join Strategies (Distributed Engines)

- **Broadcast joins:** Small table replicated to all nodes.
  Avoids shuffle. Best under 10MB (Spark default threshold).
- **Shuffle/hash joins:** Both sides redistributed by join
  key. Required for large-large joins.
- **Sort-merge joins:** Both sides sorted, then merged.
  Efficient when pre-sorted.
- **Collocated joins:** Tables partitioned on join key can
  join locally without shuffle.
- **Avoid skew:** Highly skewed join keys cause hot spots.
  Consider pre-aggregating or salting.
- Spark: `/*+ BROADCAST(t) */`, `/*+ MERGE(t) */`,
  `/*+ SHUFFLE_HASH(t) */`. Priority:
  broadcast > merge > shuffle_hash.
- Databricks: Same Spark hints. Adaptive Query Execution
  (AQE) auto-optimises join strategy at runtime.
- Snowflake: No hints. Ensure join columns have matching
  data types.

```sql
/* Spark: broadcast small dimension table */
select /*+ BROADCAST(regions) */
    orders.id
    , regions.name
from orders
inner join regions on orders.region_id = regions.id
```

### CTEs

- **Single purpose:** CTEs should perform a single, logical
  unit of work.
- **Naming:** Use verbose names that convey purpose. Don't
  prefix/suffix with `cte`.
- **Documentation:** Comment CTEs with confusing or notable
  logic.
- **Prefer CTEs:** Use CTEs rather than subqueries for
  readability and reusability.

```sql
/* Good */
with
    paying_customers as (
        select *
        from customers
        where plan_name != 'free'
    )

select ...
from paying_customers

/* Bad */
select ...
from (
    select * from customers where plan_name != 'free'
) as paying_customers
```

### Naming

- **Primary keys:** Name single-column primary keys `id`
  for clarity in joins.
- **Dates (UTC):** `<event>_date` for dates, `<event>_at`
  for timestamps.
- **Dates (timezone):** Suffix with timezone indicator
  (`order_date_et`, `created_at_pt`).
- **Booleans:** Prefix with verb (`is_`, `was_`, `has_`,
  `had_`, `does_`, `did_`).
- **Units:** Suffix numeric columns with units (`price_usd`,
  `weight_kg`).
- **Aliases:** Avoid unnecessary aliases, especially
  initialisms. Don't alias tables with 3 words or fewer.

```sql
/* Good */
select
    customers.email
    , orders.invoice_number
from customers
inner join orders on customers.id = orders.customer_id

/* Bad */
select c.email, o.invoice_number
from customers as c
inner join orders as o on c.id = o.customer_id
```

### Formatting

The overarching pattern: if there's only one thing, put it on
the same line as the keyword. If multiple, put each on its own
line indented one level.

- **Alignment:** Left-align everything.
- **Indentation:** Use 4 spaces.
- **Operators:** Never end a line with `and`, `or`, `+`,
  `||`, etc. Put operators at the start of continuation
  lines.
- **Commas:** Use leading commas on continuation lines,
  followed by a space.

#### Select Clause

```sql
/* Single column */
select id

/* Multiple columns */
select
    id
    , email

/* With distinct */
select distinct
    state
    , country
```

#### From Clause

```sql
/* Single join condition */
from customers
left join orders on customers.id = orders.customer_id

/* Multiple join conditions */
from customers
left join orders on
    customers.id = orders.customer_id
    and customers.region_id = orders.region_id
```

#### Where Clause

```sql
/* Single condition */
where email like '%@domain.com'

/* Multiple conditions */
where
    email like '%@domain.com'
    and plan_name != 'free'
```

#### Group By and Order By

```sql
/* Column numbers on one line */
/* Prefer column names over numbers */
group by 1, 2, 3

/* Column names: single on same line, multiple indented */
order by
    plan_name
    , signup_month
```

#### CTE Formatting

```sql
with
    paying_customers as (
        select ...
        from customers
    )

    , paying_customers_per_month as (
        /* CTE comments go here */
        select ...
        from paying_customers
    )

select ...
from paying_customers_per_month
```

#### Case Statements

- Single `when` on one line if short enough.
- Multi-line: indent `when`/`else` one level, `end` at same
  level as `case`.
- If after leading comma, align `end` with `case` using two
  extra spaces.

```sql
/* Short form */
select
    case when status_code = 1 then 'Active' else 'Inactive' end as status

/* Long form */
select
    case
        when status_code = 1 then 'Active'
        else 'Inactive'
    end as status
    , case
          when status_code = 1
              and deleted_at is null
              then 'Active'
          else 'Inactive'
      end as detailed_status
```

#### Window Functions

```sql
/* Short form */
row_number() over (partition by customer_id order by created_at) as order_rank

/* Long form */
row_number() over (
    partition by customer_id
    order by created_at
  ) as order_rank
```

#### In Lists

```sql
/* Break long lists */
where email in (
    'user-1@example.com'
    , 'user-2@example.com'
    , 'user-3@example.com'
)
```

#### Parentheses

- Don't put extra spaces inside parentheses.

```sql
/* Good */
where plan_name in ('monthly', 'yearly')

/* Bad */
where plan_name in ( 'monthly', 'yearly' )
```

## Terraform

Infrastructure as Code using Terraform/OpenTofu, orchestrated
with Terragrunt.

### Tooling

#### Terragrunt

- Use `terragrunt hclfmt` to format `.hcl` files
- Use `terragrunt validate-inputs` to validate inputs
- Use `terragrunt run-all <command>` for multi-unit operations
- Use `terragrunt stack generate` for stacks

#### Terraform

- Use `terraform fmt` to format `.tf` files
- Use `terraform validate` to check syntax and internal consistency
- Use `tflint` for linting code for best practices
- Use `checkov` or `tfsec` for security compliance
- Use `terraform-docs` to generate documentation

### Repository Structure

Separate modules from live (deployment) repos. Choose between
traditional or stacks-based organisation.

#### Traditional Structure

Individual `terragrunt.hcl` files per resource, organised by
account/project and region:

```text
infrastructure-live/
├── terragrunt.hcl              # Root config (providers, state)
├── _common/                    # Shared templates
├── _modules/                   # Local modules (or use external)
├── <account>/                  # AWS: account, GCP: project
│   ├── account.hcl             # Account/project-level vars
│   ├── _global/                # Account-wide resources
│   └── <region>/
│       ├── region.hcl
│       └── <resource>/
│           └── terragrunt.hcl  # Hand-written config
```

#### Stacks Structure

`terragrunt.stack.hcl` files that reference a units catalogue and
generate configs:

```text
infrastructure-live/
├── terragrunt.hcl              # Root config (providers, state)
├── catalog/                    # Units catalog (or external git repo)
│   └── units/
│       ├── vpc/
│       │   └── terragrunt.hcl
│       └── rds/
│           └── terragrunt.hcl
├── <account>/
│   └── <region>/
│       └── terragrunt.stack.hcl   # Defines which units to deploy
```

Run `terragrunt stack generate` to create the actual
`terragrunt.hcl` files (by default in `.terragrunt-stack/`, or
in-place with `no_dot_terragrunt_stack = true`).

#### Conventions

- Prefix non-deployable folders with `_`
- Right-size modules: group resources that deploy together and
  share ownership
- State paths mirror folder structure
- Use three-part naming for module repositories:
  `terraform-<PROVIDER>-<NAME>`

### Variable Hierarchy

Load variables at appropriate levels using
`find_in_parent_folders()`:

```hcl
locals {
  account_vars = read_terragrunt_config(find_in_parent_folders("account.hcl"))
  region_vars  = read_terragrunt_config(find_in_parent_folders("region.hcl"))
}
```

### Include Patterns

Use double-include for DRY resource configs:

```hcl
include "root" {
  path = find_in_parent_folders()
}

include "common" {
  path   = "${dirname(find_in_parent_folders())}/_common/vpc.hcl"
  expose = true
}

terraform {
  source = "${include.common.locals.source_base_url}"
}

inputs = { name = "my-vpc" }
```

### Provider and State Generation

Define once in root using `generate` blocks:

```hcl
generate "provider" {
  path      = "provider.tf"
  if_exists = "overwrite_terragrunt"
  contents  = <<EOF
provider "aws" {
  region = "${local.region_vars.locals.aws_region}"
}
EOF
}

remote_state {
  backend = "s3"  # or "gcs" for GCP
  config = {
    bucket = "${local.account_vars.locals.account_name}-tfstate"
    key    = "${path_relative_to_include()}/terraform.tfstate"
  }
}
```

### Dependencies

```hcl
dependency "vpc" {
  config_path = "../vpc"
  mock_outputs = { vpc_id = "vpc-mock" }
  mock_outputs_allowed_terraform_commands = ["validate", "plan"]
}

inputs = { vpc_id = dependency.vpc.outputs.vpc_id }
```

### Stacks

**When to use:**

- `unit` blocks: Single infrastructure components (VPC, database)
- `stack` blocks: Reusable patterns of components to provision together

```hcl
## terragrunt.stack.hcl
locals {
  units_path = find_in_parent_folders("catalog/units")
}

unit "vpc" {
  source = "git::git@github.com:acme/infra-catalog.git//units/vpc?ref=v1.0.0"
  path   = "vpc"
  values = {
    name = "prod-vpc"
    cidr = "10.0.0.0/16"
  }
}

unit "database" {
  source = "${local.units_path}/rds"
  path   = "database"
  values = { vpc_name = "prod-vpc" }
}
```

Commands:

- `terragrunt stack generate` to generate stack structure
- `terragrunt stack generate --filter 'prod/**'` to filter by path
- `terragrunt run --all plan` to plan all generated units

### Terraform HCL Style

The following applies to all `.tf` files, whether hand-written or
in modules.

#### Code Formatting

- Place arguments at the top of blocks, followed by nested blocks
  with one blank line separation
- Put meta-arguments (count, for_each) first, followed by other
  arguments, then nested blocks
- Place lifecycle blocks last, separated by blank lines
- Separate top-level blocks with one blank line

#### Resource Organisation

- Define data sources before the resources that reference them
- Group related resources together (networking, compute, storage)
- Order resource parameters: meta-arguments, resource-specific
  parameters, nested blocks, lifecycle, depends_on

#### Resource Naming

- Use descriptive nouns separated by underscores
- Do not include the resource type in the resource name
- Example: `resource "aws_instance" "web_server" {}` not
  `resource "aws_instance" "webserver_instance" {}`

#### Variables and Outputs

- Define `type` and `description` for every variable
- Include reasonable `default` values for optional variables
- Set `sensitive = true` for passwords and private keys
- Order variable parameters: type, description, default,
  sensitive, validation blocks
- Order output parameters: description, value, sensitive
- Use descriptive names with underscores

#### Comments

- Use `#` for comments (not `//` or `/* */`)
- Write self-documenting code; use comments only to clarify
  complexity
- Add comments above resource blocks to explain non-obvious
  business logic

#### Local Values

- Use local values sparingly to avoid making code harder to
  understand
- Define in `locals.tf` if referenced across multiple files
- Define at the top of a file if specific to that file only

#### Dynamic Resource Management

- Use `count` for nearly identical resources
- Use `for_each` when resources need distinct values that cannot
  be derived from integers
- Use `count` with conditional expressions:
  `count = var.enable_feature ? 1 : 0`

#### Provider Configuration

- Always include a default provider configuration
- Define all providers in the same file (`providers.tf`)
- Define the default provider first, then aliased providers
- Use `alias` as the first parameter in non-default provider
  blocks

#### Version Management

- Pin Terraform version using `required_version` in terraform
  block
- Pin provider versions using exact versions in
  `required_providers`
- Pin module versions when sourcing from registries
- Prefer the pessimistic constraint operator (`~>`) for modules
  and providers
- Avoid open-ended constraints (`>`, `>=` without upper bound) in
  production

#### Security and Secrets

- Never commit `terraform.tfstate` files or `.terraform`
  directories
- Use dynamic provider credentials when possible
- Access secrets from external secret management systems
- Use environment variables for provider credentials

#### Testing and Validation

- Write Terraform tests for modules using the test
  framework
- Use variable validation blocks for restrictive requirements
- Include input validation with meaningful error messages

### Terraform Modules

When creating reusable Terraform modules (not Terragrunt
units):

#### Module Structure

```text
terraform-<provider>-<name>/
├── README.md
├── main.tf
├── variables.tf
├── outputs.tf
├── providers.tf
├── locals.tf
└── modules/
    └── <nested>/
```

#### Required Files

- `main.tf`: Primary resource and data source definitions
- `variables.tf`: Input variable definitions (alphabetical order)
- `outputs.tf`: Output value definitions (alphabetical order)
- `README.md`: Module purpose, usage, and examples

#### Guidance

- Keep modules focused on single infrastructure concerns
- Split large configurations into logical files
  (e.g., `network.tf`, `compute.tf`)
- Include `README.md` for external-facing nested modules; omit
  for internal-only

## TypeScript

### Tooling

- If npm or pnpm scripts are configured, ask the user
  to confirm first. Otherwise:
  - Use `tsc --noEmit` to type check code
  - Use `eslint` to lint code for best practices
  - Use `biome format` to format code. If unavailable,
    use `prettier` instead.

### General Best Practices

- **Modern browsers:** Assume modern browser support
  unless otherwise specified. Skip polyfills for
  ES2020+ features.
- **Immutability:** Favour `readonly`, `as const`, and
  immutable patterns. Avoid mutation where practical.
- **Pure functions:** Prefer functions without side
  effects. Isolate side effects at boundaries.
- **Composition over inheritance:** Favour small
  composable functions and interfaces over class
  hierarchies.
- **Simplicity:** Avoid clever abstractions. Repetition
  is often cheaper than the wrong abstraction.
- **Explicit over implicit:** Be explicit about types at
  boundaries, nullability, and error conditions.

### Imports & Exports

- **Named exports only:** Avoid default exports to
  prevent ambiguity and improve refactoring.
- **Import style:** Use named imports for
  frequently-used symbols. Use namespace imports
  (`import * as foo`) for large APIs.
- **Type imports:** Use `import type` and `export type`
  for type-only references.
- **Relative paths:** Prefer relative imports within
  projects. Limit parent traversal depth
  (`../../../` is a smell).
- **No namespaces:** Use ES6 modules exclusively.
  TypeScript `namespace` is disallowed.
- **Export visibility:** Only export symbols used outside
  the module.
- **No mutable exports:** Use getter functions if
  external code needs dynamic values.

### Naming

- **UpperCamelCase:** Classes, interfaces, types, enums,
  decorators, type parameters.
- **lowerCamelCase:** Variables, parameters, functions,
  methods, properties, module aliases.
- **CONSTANT_CASE:** Global constants, enum values.
- **No decoration:** Don't encode type info in names. No
  `IMyInterface`, no Hungarian notation, no trailing
  underscores.
- **Acronyms as words:** `loadHttpUrl` not
  `loadHTTPURL`. Treat acronyms as single words.
- **Descriptive names:** Avoid abbreviations unfamiliar
  to external readers. Short names OK for variables in
  scope under 10 lines.

### Variables

- **const by default:** Use `const` unless reassignment
  is required, then use `let`.
- **Never var:** `var` is disallowed.
- **One per declaration:** Declare one variable per
  statement.

### Arrays

- **Literal syntax:** Use `[]` not `Array()` constructor.
- **Simple types:** Use `T[]` or `readonly T[]` for
  simple element types.
- **Complex types:** Use `Array<T>` when element type is
  complex.
- **No sparse arrays:** Don't set non-numeric properties
  on arrays.
- **Spread for iterables:** Use spread syntax for copying
  or concatenating arrays.

### Objects

- **Literal syntax:** Use `{}` not `Object()` constructor.
- **No for-in:** Use `Object.keys()`,
  `Object.values()`, `Object.entries()`, or `for...of`
  instead.
- **Destructuring:** Keep parameter destructuring simple
  (single level, unquoted properties).
- **Prefer Map/Set:** Use `Map` and `Set` over
  object-based dictionaries when keys are dynamic.

### Classes

- **Visibility:** Minimise exposure. Omit `public`
  modifier (it's the default). Use `private` or
  `protected` explicitly.
- **readonly:** Mark properties never reassigned outside
  constructor.
- **Parameter properties:** Use constructor parameter
  properties to reduce boilerplate.
- **Field initializers:** Initialise members at
  declaration when possible.
- **No private fields:** Use TypeScript `private`
  modifier, not `#ident` syntax.
- **Getters must be pure:** No side effects in getters.
  Don't define pass-through accessors.
- **No prototype manipulation:** Only framework code may
  touch prototypes.

### Functions

- **Function declarations:** Prefer `function foo()`
  over `const foo = () =>` for named functions.
- **Arrow functions:** Use in method bodies for `this`
  access, callbacks, and inline functions.
- **Concise arrow bodies:** Use for expressions that
  return values. Use block bodies for side effects.
- **Rest parameters:** Use instead of `arguments` object.
- **No this rebinding:** Don't use `.bind()`, `.call()`,
  `.apply()` to rebind `this`. Use arrow functions.

### Control Flow

- **Always brace:** Use braced blocks even for single
  statements.
- **for-of over for-in:** Prefer `for...of` for
  iteration. If using `for...in`, check
  `hasOwnProperty`.
- **Strict equality:** Always use `===` and `!==`.
  Exception: `== null` to match both `null` and
  `undefined`.
- **Switch default:** All switch statements require a
  `default` case (place last).
- **No fall-through:** Each case must terminate. Empty
  cases may fall through.

### Error Handling

- **Throw Error objects:** Always `throw new Error()`,
  never throw primitives.
- **Catch as Error:** Assume caught values are `Error`
  type. Add comments for non-Error throws.
- **Empty catch:** Only with explanatory comment.

### Type System

- **Inference:** Rely on inference for trivially inferred
  types (literals, `new` expressions).
- **Explicit generics:** Specify type parameters when
  initialising empty collections.
- **Interfaces over type aliases:** Prefer `interface`
  for object types. Use `type` for unions,
  intersections, mapped types.
- **Optional fields:** Use `?` syntax, not
  `| undefined`.
- **No null in aliases:** Never include `| null` or
  `| undefined` in type alias definitions. Add at
  usage.
- **unknown over any:** Use `unknown` for truly unknown
  types. Narrow with type guards before use.
- **Tuple types:** Prefer tuples over Pair-style
  interfaces. Consider inline object literals for 2-3
  properties.

### Type Assertions

- **Avoid assertions:** Prefer runtime checks or proper
  typing.
- **as syntax:** When necessary, use `as` (not angle
  brackets).
- **Double assertions:** Use `as unknown as Type` when
  required.
- **Object literals:** Use type annotations (`:`) not
  assertions (`as`).
- **Non-null assertions:** Avoid `!`. Prefer explicit
  null checks.

### Strings

- **Template literals:** Use for interpolation,
  multi-line strings, or complex concatenation. Not for
  simple static strings.
- **No line continuations:** Don't use backslash at line
  end.

### Type Coercion

- **String():** Use `String(x)` or template literals,
  not `'' + x`.
- **Boolean():** Use explicit comparison for enums.
  Implicit coercion OK for other types in conditionals.
- **Number():** Use `Number(x)` with `isFinite()` check.
  Avoid `parseInt`/`parseFloat` unless parsing
  non-base-10.

### Comments

- **JSDoc for documentation:** Use `/** */` for
  user-facing documentation.
- **Line comments for implementation:** Use `//` for
  implementation notes.
- **No block comments:** Use multiple `//` lines,
  not `/* */`.
- **Markdown in JSDoc:** Write JSDoc content in Markdown.

### Disallowed

- **Wrapper objects:** Never use `String`, `Boolean`,
  `Number`, `Object` constructors.
- **const enum:** Use plain `enum` instead.
- **debugger:** Not in production code.
- **with:** Never use.
- **eval:** No dynamic code evaluation.
- **@ts-ignore:** Use proper typing instead.
  `@ts-expect-error` only in tests with explanation.
- **Modifying builtins:** Never extend or modify
  built-in prototypes.
