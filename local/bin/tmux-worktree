#!/bin/bash
#/ Usage: tmux-worktree [options] [repo-path]
#/
#/ Create or attach to a tmux session for a git repository, with a window per worktree.
#/
#/ Arguments:
#/   repo-path    Path to a git repository. If omitted, uses fzf to select from ~/projects.
#/
#/ Options:
#/   -d, --direnv-allow    Run 'direnv allow' in worktrees that have an .envrc file
#/   -h, --help            Show this help
#/
#/ Behaviour:
#/   - Creates a tmux session named after the repository directory
#/   - Creates one window per worktree, named after the worktree directory
#/   - If the session exists, syncs windows with current worktrees and attaches

set -o errexit -o errtrace -o pipefail -o nounset

usage() {
  grep '^#/' "$0" | cut -c4-
  exit 0
}

DIRENV_ALLOW=0

# Parse options
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h | --help)
      usage
      ;;
    -d | --direnv-allow)
      DIRENV_ALLOW=1
      shift
      ;;
    -*)
      echo "Unknown option: $1" >&2
      usage
      ;;
    *)
      break
      ;;
  esac
done

log() { echo "[tmux-worktree] $*" >&2; }

error() {
  log "error: $*"
  exit 1
}

# Run direnv allow if enabled and .envrc exists
maybe_direnv_allow() {
  local path="$1"

  if [[ "${DIRENV_ALLOW}" -eq 1 ]] && [[ -f "${path}/.envrc" ]]; then
    log "running 'direnv allow' in ${path/#${HOME}/\~}"
    direnv allow "${path}"
  fi
}

# Select a repository from ~/projects using fzf
select_repo() {
  local projects_dir="${HOME}/projects"

  if [[ ! -d "${projects_dir}" ]]; then
    error "projects directory not found: ${projects_dir}"
  fi

  local repo
  repo=$(
    find "${projects_dir}" -maxdepth 3 -name .git 2>/dev/null \
      | sed 's|/\.git$||' \
      | sort \
      | fzf --prompt="Select repo: "
  ) || error "no repository selected"

  echo "${repo}"
}

# Get worktrees as newline-separated list of "path:name" pairs
# Limited to 9 most recently modified worktrees
get_worktrees() {
  local repo_path="$1"
  local worktree_path=""
  local name=""
  local mtime=""
  local -a entries=()

  # Collect worktrees with birth times
  while IFS= read -r line; do
    if [[ "${line}" =~ ^worktree\ (.+)$ ]]; then
      worktree_path="${BASH_REMATCH[1]}"
      name=$(basename "${worktree_path}")
      name="${name//_/-}"
      # Get mtime (macOS stat -f %m)
      mtime=$(stat -f %m "${worktree_path}" 2>/dev/null || echo "0")
      entries+=("${mtime}:${worktree_path}:${name}")
    fi
  done < <(git -C "${repo_path}" worktree list --porcelain)

  # Sort by mtime descending (most recently modified first), limit to 9
  printf '%s\n' "${entries[@]}" \
    | sort -t: -k1 -rn \
    | head -n 9 \
    | cut -d: -f2-
}

# Get current tmux window names for a session
get_window_names() {
  local session="$1"
  tmux list-windows -t "${session}" -F "#{window_name}" 2>/dev/null || true
}

# Check if a tmux session exists
session_exists() {
  local session="$1"
  tmux has-session -t "${session}" 2>/dev/null
}

# Create a new window in a session
create_window() {
  local session="$1"
  local name="$2"
  local path="$3"
  local display_path="${path/#${HOME}/\~}"

  log "creating window '${name}' at '${display_path}'"
  if [[ ! -d "${path}" ]]; then
    log "warning: path does not exist: ${display_path}"
  fi
  tmux new-window -t "${session}" -n "${name}" -c "${path}"
  maybe_direnv_allow "${path}"
}

# Sync session windows with worktrees
sync_session() {
  local session="$1"
  local -a worktrees=()
  local -a worktree_names=()

  # Build arrays of worktree paths and names
  while IFS=':' read -r path name; do
    worktrees+=("${path}:${name}")
    worktree_names+=("${name}")
  done < <(get_worktrees "${repo_path}")

  # Get current window names
  local -a current_windows=()
  while IFS= read -r window; do
    [[ -n "${window}" ]] && current_windows+=("${window}")
  done < <(get_window_names "${session}")

  # Create windows for new worktrees
  for entry in "${worktrees[@]}"; do
    local path="${entry%%:*}"
    local name="${entry##*:}"
    local found=0

    for existing in "${current_windows[@]}"; do
      if [[ "${existing}" == "${name}" ]]; then
        found=1
        break
      fi
    done

    if [[ "${found}" -eq 0 ]]; then
      log "creating window: ${name}"
      create_window "${session}" "${name}" "${path}"
    fi
  done

  # Remove windows that no longer have worktrees
  for window in "${current_windows[@]}"; do
    local found=0

    for name in "${worktree_names[@]}"; do
      if [[ "${name}" == "${window}" ]]; then
        found=1
        break
      fi
    done

    if [[ "${found}" -eq 0 ]]; then
      log "removing window: ${window}"
      tmux kill-window -t "${session}:${window}" 2>/dev/null || true
    fi
  done
}

# Create a new session with worktree windows
create_session() {
  local session="$1"
  local first=1

  while IFS=':' read -r path name; do
    if [[ "${first}" -eq 1 ]]; then
      log "creating session: ${session}"
      tmux new-session -d -s "${session}" -n "${name}" -c "${path}"
      maybe_direnv_allow "${path}"
      first=0
    else
      log "creating window: ${name}"
      create_window "${session}" "${name}" "${path}"
    fi
  done < <(get_worktrees "${repo_path}")

  if [[ "${first}" -eq 1 ]]; then
    error "no worktrees found in repository"
  fi
}

main() {
  local repo_path

  # Get repo path from argument or fzf selection
  if [[ $# -ge 1 ]]; then
    repo_path="$1"
  else
    repo_path=$(select_repo)
  fi

  # Expand ~ if present
  repo_path="${repo_path/#\~/${HOME}}"

  # Validate repo path
  if [[ ! -d "${repo_path}" ]]; then
    error "directory not found: ${repo_path}"
  fi

  if ! git -C "${repo_path}" rev-parse --git-dir >/dev/null 2>&1; then
    error "not a git repository: ${repo_path}"
  fi

  # Session name from path relative to ~/projects, or basename for external paths
  local session
  local projects_dir="${HOME}/projects"

  if [[ "${repo_path}" == "${projects_dir}/"* ]]; then
    # Path is under ~/projects, use relative path as session name
    local relative_path="${repo_path#"${projects_dir}"/}"
    session="${relative_path//\//-}"
  else
    # External path, use basename only
    session=$(basename "${repo_path}")
  fi

  # Sanitise session name (tmux doesn't allow dots or colons, prefer dashes)
  session="${session//./-}"
  session="${session//:/-}"
  session="${session//_/-}"

  if session_exists "${session}"; then
    log "syncing session: ${session}"
    sync_session "${session}"
  else
    create_session "${session}"
  fi

  # Attach or switch to session
  if [[ -n "${TMUX:-}" ]]; then
    tmux switch-client -t "${session}"
  else
    tmux attach-session -t "${session}"
  fi
}

main "$@"
