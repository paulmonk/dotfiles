#!/usr/bin/env python3
"""Unified notification script for coding agents.

Sends macOS desktop notifications via terminal-notifier. Auto-detects
which agent is calling based on the JSON payload structure:

  Claude Code  stdin JSON with hook_event_name (MUST passthrough to stdout)
  Codex        argv[1] JSON with type: agent-turn-complete
  OpenCode     argv[1] JSON with type: session.idle

Input formats:
  Claude Code (stdin, must passthrough):
    {"hook_event_name": "Stop", "cwd": "...", "session_id": "..."}
    {"hook_event_name": "Notification", "notification_type": "permission_prompt", ...}

  Codex (argv[1]):
    {"type": "agent-turn-complete", "thread-id": "...", "cwd": "...",
     "last-assistant-message": "..."}

  OpenCode (argv[1]):
    {"type": "session.idle", "cwd": "..."}
    Note: session-id is accepted but not currently sent by the plugin.
"""

from __future__ import annotations

import datetime as dt
import json
import os
import subprocess
import sys
from pathlib import Path
from typing import Any, Final, TextIO

# Set AGENT_NOTIFY_LOG to a file path to enable persistent debug logging.
LOG_FILE: Final[str] = os.getenv("AGENT_NOTIFY_LOG", "")

# Codex can include the full assistant response in the notification payload.
MAX_MESSAGE_LENGTH: Final[int] = 200

# Claude Code keeps stdin open during cancels/timeouts, so we read
# incrementally up to this cap to avoid unbounded memory growth.
MAX_STDIN_BYTES: Final[int] = 1024 * 1024

# Read buffer size for the incremental stdin JSON parser.
CHUNK_SIZE: Final[int] = 4096

# If the buffer exceeds this size without producing a valid JSON object,
# treat the input as irreparably malformed rather than retrying forever.
MAX_PARSE_BUFFER: Final[int] = 65536


def log(message: str) -> None:
    """Write a diagnostic line to stderr and optionally to a log file.

    Args:
        message: Content to write.
    """
    sys.stderr.write(f"{message}\n")
    if LOG_FILE:
        try:
            with open(LOG_FILE, "a") as f:
                f.write(f"{dt.datetime.now().isoformat()} {message}\n")
        except IOError as e:
            sys.stderr.write(f"[agent-notify] Cannot write to {LOG_FILE}: {e}\n")


def read_stdin_json(
    stream: TextIO = sys.stdin, *, max_size: int = MAX_STDIN_BYTES
) -> dict[str, Any]:
    """Read a JSON payload from stdin without waiting for EOF.

    Claude Code keeps the pipe open during cancels/timeouts, so we
    parse incrementally and return as soon as we have a complete
    JSON object.

    Args:
        stream: Input stream to read from.
        max_size: Maximum buffer size before rejecting input.

    Returns:
        Parsed JSON object, or empty dict on EOF.

    Raises:
        json.JSONDecodeError: If input is incomplete or exceeds max size.
    """
    decoder = json.JSONDecoder()
    buffer = ""
    encoding = getattr(stream, "encoding", "utf-8") or "utf-8"
    binary_stream = getattr(stream, "buffer", None)

    if binary_stream is not None:
        read_fn = getattr(binary_stream, "read1", None) or binary_stream.read

        def _read_chunk() -> str:
            chunk = read_fn(CHUNK_SIZE)
            return chunk.decode(encoding, errors="replace") if chunk else ""
    else:

        def _read_chunk() -> str:
            return stream.read(CHUNK_SIZE)

    while True:
        chunk = _read_chunk()
        if not chunk:
            if buffer.strip():
                raise json.JSONDecodeError(
                    "Incomplete JSON input", buffer, len(buffer)
                )
            return {}

        buffer += chunk
        if len(buffer) > max_size:
            raise json.JSONDecodeError("Input exceeds max size", buffer[:100], 0)
        buffer = buffer.lstrip()
        if not buffer:
            continue

        try:
            result, _ = decoder.raw_decode(buffer)
            return result
        except json.JSONDecodeError:
            if len(buffer) > MAX_PARSE_BUFFER:
                raise json.JSONDecodeError(
                    "Buffer exceeded 64 KiB without completing a JSON object",
                    buffer[:200],
                    0,
                )
            continue


def read_input() -> tuple[dict[str, Any], bool]:
    """Read JSON from argv[1] or stdin.

    Returns:
        Tuple of (payload, needs_passthrough) where needs_passthrough
        is True when input came from stdin (Claude Code hook protocol).
    """
    if len(sys.argv) >= 2:
        return json.loads(sys.argv[1]), False
    return read_stdin_json(), True


def send_notification(
    title: str,
    *,
    message: str,
    sound: str = "default",
    subtitle: str = "",
    group: str = "agent",
) -> bool:
    """Send a macOS notification via terminal-notifier.

    Args:
        title: Notification title.
        message: Notification body text.
        sound: Sound name or "none" to disable.
        subtitle: Optional subtitle shown below title.
        group: Notification group identifier for stacking.

    Returns:
        True if the notification was sent successfully.
    """
    # -sender and -activate are omitted: -sender hangs on macOS Ventura+
    # for some apps including Ghostty
    # (https://github.com/julienXX/terminal-notifier/issues/301),
    # and -activate depends on it.
    cmd = [
        "terminal-notifier",
        "-title",
        title,
        "-message",
        message,
        "-group",
        group,
        "-ignoreDnD",
    ]

    if subtitle:
        cmd.extend(["-subtitle", subtitle])
    if sound and sound != "none":
        cmd.extend(["-sound", sound])

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=5)
        if result.returncode != 0:
            log(
                f"[agent-notify] terminal-notifier failed "
                f"(exit {result.returncode}): {result.stderr.strip()}"
            )
            return False
        return True
    except FileNotFoundError:
        log(
            "[agent-notify] terminal-notifier not found. "
            "Install with: brew install terminal-notifier"
        )
        return False
    except subprocess.SubprocessError as e:
        log(f"[agent-notify] Error: {e}")
        return False


def _project_context(cwd: str, *, session_id: str) -> str:
    """Build a 'project (short-id)' subtitle string.

    Args:
        cwd: Working directory path.
        session_id: Session or thread identifier.

    Returns:
        Formatted subtitle like "myproject (a3f7b2c)".
    """
    project = Path(cwd).name if cwd else ""
    short_id = session_id[:7] if session_id else ""
    if short_id:
        return f"{project} ({short_id})"
    return project


def _truncate(text: str, *, limit: int = MAX_MESSAGE_LENGTH) -> str:
    """Truncate text to a maximum length with an ellipsis suffix.

    Args:
        text: String to truncate.
        limit: Maximum character count including ellipsis.

    Returns:
        Original text if within limit, otherwise truncated with "...".
    """
    if len(text) > limit:
        return text[: limit - 3] + "..."
    return text


def handle_claude_code(payload: dict[str, Any]) -> None:
    """Handle Claude Code Notification and Stop events.

    Args:
        payload: Parsed JSON from Claude Code's hook protocol.
    """
    hook_event = payload.get("hook_event_name", "")
    subtitle = _project_context(
        payload.get("cwd", ""), session_id=payload.get("session_id", "")
    )

    if hook_event == "Notification":
        notification_type = payload.get("notification_type", "")
        if notification_type == "permission_prompt":
            send_notification(
                "Claude Code",
                message="Permission needed",
                subtitle=subtitle,
                group="claude-code",
            )
    elif hook_event == "Stop":
        send_notification(
            "Claude Code",
            message="Task completed",
            subtitle=subtitle,
            group="claude-code",
        )


def handle_codex(payload: dict[str, Any]) -> None:
    """Handle Codex agent-turn-complete events.

    Args:
        payload: Parsed JSON from Codex's notify protocol.
    """
    thread_id = payload.get("thread-id", "")
    last_message = payload.get("last-assistant-message", "Turn complete")
    subtitle = _project_context(payload.get("cwd", ""), session_id=thread_id)
    group = f"codex-{thread_id}" if thread_id else "codex"

    send_notification(
        "Codex",
        message=_truncate(last_message),
        subtitle=subtitle,
        group=group,
    )


def handle_opencode(payload: dict[str, Any]) -> None:
    """Handle OpenCode session.idle events.

    Args:
        payload: Parsed JSON from OpenCode's plugin protocol.
    """
    subtitle = _project_context(
        payload.get("cwd", ""), session_id=payload.get("session-id", "")
    )

    send_notification(
        "OpenCode",
        message="Task completed",
        subtitle=subtitle,
        group="opencode",
    )


def main() -> int:
    """Auto-detect agent type from JSON payload and send notification.

    Returns:
        Exit code (always 0 to avoid blocking any agent).
    """
    payload: dict[str, Any] = {}
    # Determine passthrough before parsing so the error handler can
    # still echo to stdout if Claude Code sends malformed JSON.
    needs_passthrough = len(sys.argv) < 2

    try:
        payload, needs_passthrough = read_input()

        if not payload:
            log("[agent-notify] Empty payload (EOF with no data)")
        elif "hook_event_name" in payload:
            handle_claude_code(payload)
        elif payload.get("type") == "agent-turn-complete":
            handle_codex(payload)
        elif payload.get("type") == "session.idle":
            handle_opencode(payload)
        else:
            log(f"[agent-notify] Unknown payload type: {payload.get('type', 'none')}")
    except (json.JSONDecodeError, ValueError) as e:
        log(f"[agent-notify] Invalid input: {e}")
    except Exception as e:
        log(f"[agent-notify] Unexpected error: {e}")
    finally:
        # Claude Code hooks require writing input back to stdout.
        if needs_passthrough:
            try:
                sys.stdout.write(json.dumps(payload))
            except Exception as e:
                log(f"[agent-notify] Failed to write passthrough: {e}")

    return 0


if __name__ == "__main__":
    sys.exit(main())
