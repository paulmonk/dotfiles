#!/bin/bash

#/ Claude Code custom statusline (two-line)
#/
#/ [Opus]  ▸ dotfiles  #abc123d  ⎇ master (wt)  ████████⣿⣿⣿⣿ 62%  ¤ $0.12  ⏲ 5m 23s  ↻ 85%
#/
#/ https://code.claude.com/docs/en/statusline

set -o errexit -o errtrace -o pipefail -o nounset

# Solarized Dark High Contrast (24-bit RGB)
readonly C_RED="\033[38;2;220;50;47m"
readonly C_ORANGE="\033[38;2;203;75;22m"
readonly C_YELLOW="\033[38;2;181;137;0m"
readonly C_GREEN="\033[38;2;133;153;0m"
readonly C_CYAN="\033[38;2;42;161;152m"
readonly C_BLUE="\033[38;2;38;139;210m"
readonly C_BASE1="\033[38;2;147;161;161m"
readonly C_BASE00="\033[38;2;101;123;131m"
readonly C_DIM="\033[2m"
readonly C_RESET="\033[0m"

# Read all stdin JSON in one go, extract everything in a single jq call.
# Uses remaining_percentage (accounts for compaction reserves) with
# fallback to raw token calculation.
#
# Delimiter: pipe (|) instead of @tsv because bash IFS=$'\t' read
# treats consecutive tabs as one delimiter, swallowing empty fields.
input=$(cat)

current_dir="" session_id="" model_name="" cost="" duration_ms="" ctx_used="" cache_pct=""
IFS='|' read -r current_dir session_id model_name cost duration_ms ctx_used cache_pct < <(
  echo "$input" | jq -r '[
    (.workspace.current_dir // "unknown"),
    (.session_id // ""),
    (.model.display_name // "Unknown"),
    (try (.cost.total_cost_usd // 0 | . * 100 | floor / 100) catch 0),
    (.cost.total_duration_ms // 0),
    (try (
      if (.context_window.remaining_percentage // null) != null then
        100 - (.context_window.remaining_percentage | floor)
      elif (.context_window.context_window_size // 0) > 0 then
        (((.context_window.current_usage.input_tokens // 0) +
          (.context_window.current_usage.cache_creation_input_tokens // 0) +
          (.context_window.current_usage.cache_read_input_tokens // 0)) * 100 /
         .context_window.context_window_size) | floor
      else 0 end
    ) catch 0),
    (try (
      (.context_window.current_usage // {}) |
      if (.input_tokens // 0) + (.cache_read_input_tokens // 0) > 0 then
        ((.cache_read_input_tokens // 0) * 100 /
         ((.input_tokens // 0) + (.cache_read_input_tokens // 0))) | floor
      else 0 end
    ) catch 0)
  ] | join("|")'
)

# Fallback if jq failed entirely or partially.
if [[ -z ${current_dir} ]] || [[ -z ${model_name} ]]; then
  current_dir=$(echo "$input" | jq -r '.workspace.current_dir // "unknown"' 2>/dev/null)
  session_id=$(echo "$input" | jq -r '.session_id // ""' 2>/dev/null)
  model_name=$(echo "$input" | jq -r '.model.display_name // "Unknown"' 2>/dev/null)
  cost=$(echo "$input" | jq -r '(.cost.total_cost_usd // 0)' 2>/dev/null)
  duration_ms=$(echo "$input" | jq -r '(.cost.total_duration_ms // 0)' 2>/dev/null)
  ctx_used="0"
  cache_pct="0"
  : "${current_dir:=unknown}"
  : "${model_name:=Unknown}"
  : "${cost:=0}"
  : "${duration_ms:=0}"
fi

# Git info: branch name, worktree suffix.
git_branch="" git_wt=""
if cd "$current_dir" 2>/dev/null && git rev-parse --git-dir >/dev/null 2>&1; then
  git_branch=$(git symbolic-ref --short HEAD 2>/dev/null || git rev-parse --short HEAD 2>/dev/null)
  if [[ "$(git rev-parse --git-common-dir)" != "$(git rev-parse --git-dir)" ]]; then
    git_wt=" (wt)"
  fi
fi

project=$(basename "$current_dir")
short_session=${session_id:0:7}

# Strip "Claude 3.5 " or "Claude " prefix for brevity.
short_model=$(echo "$model_name" | sed -E 's/Claude [0-9.]+ //; s/^Claude //')

# Context progress bar (12 blocks wide, colour-coded).
bar_width=12
progress_bar=""
if [[ -n ${ctx_used} ]] && [[ ${ctx_used} != "null" ]] && ((ctx_used > 0)); then
  filled=$((ctx_used * bar_width / 100))
  empty=$((bar_width - filled))

  if ((ctx_used >= 80)); then
    bar_color="${C_RED}"
  elif ((ctx_used >= 50)); then
    bar_color="${C_ORANGE}"
  else
    bar_color="${C_GREEN}"
  fi

  progress_bar="${bar_color}"
  for ((i = 0; i < filled; i++)); do
    progress_bar="${progress_bar}█"
  done
  progress_bar="${progress_bar}${C_DIM}"
  for ((i = 0; i < empty; i++)); do
    progress_bar="${progress_bar}⣿"
  done
  progress_bar="${progress_bar}${C_RESET}"
fi

# Session duration (human-readable).
session_time=""
if [[ ${duration_ms} -gt 0 ]] 2>/dev/null; then
  total_sec=$((duration_ms / 1000))
  hours=$((total_sec / 3600))
  minutes=$(((total_sec % 3600) / 60))
  seconds=$((total_sec % 60))
  if ((hours > 0)); then
    session_time="${hours}h ${minutes}m"
  elif ((minutes > 0)); then
    session_time="${minutes}m ${seconds}s"
  else
    session_time="${seconds}s"
  fi
fi

# Assemble single line: model, project, session, branch, context, cost, duration, cache
out=""
out="${out}$(printf "${C_YELLOW}[%s]${C_RESET}" "$short_model")"
out="${out}$(printf "  ${C_BASE1}▸ %s${C_RESET}" "$project")"
if [[ -n ${short_session} ]]; then
  out="${out}$(printf "  ${C_CYAN}#%s${C_RESET}" "$short_session")"
fi
if [[ -n ${git_branch} ]]; then
  out="${out}$(printf "  ${C_BLUE}⎇ %s%s${C_RESET}" "$git_branch" "$git_wt")"
fi
if [[ -n ${progress_bar} ]]; then
  out="${out}$(printf "  %b ${C_BASE1}%d%%${C_RESET}" "$progress_bar" "$ctx_used")"
fi
out="${out}$(printf "  ${C_YELLOW}¤ \$%s${C_RESET}" "$cost")"
if [[ -n ${session_time} ]]; then
  out="${out}$(printf "  ${C_CYAN}⏲ %s${C_RESET}" "$session_time")"
fi
if [[ ${cache_pct} -gt 0 ]] 2>/dev/null; then
  out="${out}$(printf "  ${C_BASE00}↻ %s%%${C_RESET}" "$cache_pct")"
fi

printf '%b' "$out"
