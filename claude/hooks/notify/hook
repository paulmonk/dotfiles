#!/usr/bin/env python3
"""
Notification hook - sends desktop notifications for Claude Code events.

Handles Notification events (idle_prompt, permission_prompt) and Stop events
(task completed) using terminal-notifier on macOS.
"""

from __future__ import annotations

import datetime as dt
import json
import os
import subprocess
import sys
from enum import StrEnum
from pathlib import Path
from typing import Any, Final, TextIO

# Directory where this hook lives, used for loading config.json.
HOOK_DIR: Final[Path] = Path(__file__).parent.resolve()

# Persistent state directory shared across Claude Code hooks.
STATE_DIR: Final[Path] = Path.home() / ".claude" / "state"

# Tracks last notification time per event type to prevent spam.
COOLDOWN_FILE: Final[Path] = STATE_DIR / "notify_cooldown.json"

# Optional log file path. Set NOTIFY_HOOK_LOG env var to enable.
LOG_FILE: Final[str] = os.getenv("NOTIFY_HOOK_LOG", "")


class HookEvent(StrEnum):
    """Hook events this handler responds to."""

    NOTIFICATION = "Notification"
    STOP = "Stop"


class NotificationType(StrEnum):
    """Types of notifications that can be sent."""

    IDLE_PROMPT = "idle_prompt"
    PERMISSION_PROMPT = "permission_prompt"
    STOP = "stop"


def log(message: str) -> None:
    """Log to stderr and optionally to file.

    Args:
        message: Content to write.
    """
    sys.stderr.write(f"{message}\n")
    if LOG_FILE:
        try:
            with open(LOG_FILE, "a") as f:
                f.write(f"{dt.datetime.now().isoformat()} {message}\n")
        except IOError:
            pass


def read_hook_input(
    stream: TextIO = sys.stdin, *, max_size: int = 1024 * 1024
) -> dict[str, Any]:
    """Read a JSON payload from stdin without waiting for EOF.

    Claude keeps the pipe open during cancels/timeouts, so we parse
    incrementally and return as soon as we have a complete JSON object.

    Args:
        stream: Input stream to read from.
        max_size: Maximum buffer size before rejecting input.

    Returns:
        Parsed JSON object, or empty dict on EOF.

    Raises:
        json.JSONDecodeError: If input is incomplete or exceeds max size.
    """
    decoder = json.JSONDecoder()
    buffer = ""
    encoding = getattr(stream, "encoding", "utf-8") or "utf-8"
    binary_stream = getattr(stream, "buffer", None)

    if binary_stream is not None:
        read_fn = getattr(binary_stream, "read1", None) or binary_stream.read

        def _read_chunk() -> str:
            chunk = read_fn(4096)
            return chunk.decode(encoding, errors="replace") if chunk else ""
    else:

        def _read_chunk() -> str:
            return stream.read(4096)

    while True:
        chunk = _read_chunk()
        if not chunk:
            if buffer.strip():
                raise json.JSONDecodeError("Incomplete JSON input", buffer, len(buffer))
            return {}

        buffer += chunk
        if len(buffer) > max_size:
            raise json.JSONDecodeError("Input exceeds max size", buffer[:100], 0)
        buffer = buffer.lstrip()
        if not buffer:
            continue

        try:
            hook_input, _ = decoder.raw_decode(buffer)
            return hook_input
        except json.JSONDecodeError:
            continue


def load_config() -> dict[str, Any]:
    """Load config.json with sensible defaults.

    Returns:
        Configuration dict with event settings merged over defaults.
    """
    defaults: dict[str, Any] = {
        "events": {
            NotificationType.IDLE_PROMPT: {
                "enabled": True,
                "title": "Claude Code",
                "message": "Waiting for input",
                "sound": "default",
            },
            NotificationType.PERMISSION_PROMPT: {
                "enabled": True,
                "title": "Claude Code",
                "message": "Permission needed",
                "sound": "default",
            },
            NotificationType.STOP: {
                "enabled": True,
                "title": "Claude Code",
                "message": "Task completed",
                "sound": "default",
                "cooldown_seconds": 30,
            },
        }
    }

    config_path = HOOK_DIR / "config.json"
    if not config_path.exists():
        return defaults

    try:
        config = json.loads(config_path.read_text())
        for event, settings in defaults["events"].items():
            if event not in config.get("events", {}):
                config.setdefault("events", {})[event] = settings
            else:
                for key, value in settings.items():
                    config["events"][event].setdefault(key, value)
        return config
    except (json.JSONDecodeError, IOError) as e:
        log(f"[Notify] Config error, using defaults: {e}")
        return defaults


def check_cooldown(event_type: str, *, cooldown_seconds: int) -> bool:
    """Check if enough time has passed since last notification of this type.

    Args:
        event_type: The notification type to check cooldown for.
        cooldown_seconds: Minimum seconds between notifications.

    Returns:
        True if notification should proceed, False if still in cooldown.
    """
    if cooldown_seconds <= 0:
        return True

    try:
        if COOLDOWN_FILE.exists():
            data = json.loads(COOLDOWN_FILE.read_text())
            if (
                dt.datetime.now().timestamp() - data.get(event_type, 0)
                < cooldown_seconds
            ):
                return False
    except (json.JSONDecodeError, IOError):
        pass

    return True


def update_cooldown(event_type: str) -> None:
    """Record the current time for this event type.

    Args:
        event_type: The notification type to update cooldown for.
    """
    try:
        STATE_DIR.mkdir(parents=True, exist_ok=True)
        data = {}
        if COOLDOWN_FILE.exists():
            try:
                data = json.loads(COOLDOWN_FILE.read_text())
            except json.JSONDecodeError:
                pass
        data[event_type] = dt.datetime.now().timestamp()
        COOLDOWN_FILE.write_text(json.dumps(data))
    except IOError as e:
        log(f"[Notify] Failed to update cooldown: {e}")


def send_notification(
    title: str, *, message: str, sound: str = "default", subtitle: str = ""
) -> bool:
    """Send a macOS notification via terminal-notifier.

    Args:
        title: Notification title.
        message: Notification body text.
        sound: Sound name or "none" to disable.
        subtitle: Optional subtitle shown below title.

    Returns:
        True if notification was sent successfully.
    """
    cmd = [
        "terminal-notifier",
        "-title",
        title,
        "-message",
        message,
        "-group",
        "claude-code",
        "-ignoreDnD",
    ]

    if subtitle:
        cmd.extend(["-subtitle", subtitle])

    if sound and sound != "none":
        cmd.extend(["-sound", sound])

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=5)
        if result.returncode != 0:
            log(f"[Notify] terminal-notifier failed: {result.stderr}")
            return False
        return True
    except FileNotFoundError:
        log(
            "[Notify] terminal-notifier not found. Install with: brew install terminal-notifier"
        )
        return False
    except subprocess.TimeoutExpired:
        log("[Notify] terminal-notifier timed out")
        return False
    except subprocess.SubprocessError as e:
        log(f"[Notify] Error: {e}")
        return False


def process_event(
    event_type: str, *, config: dict[str, Any], project: str = ""
) -> None:
    """Handle notification for a given event type.

    Args:
        event_type: The notification type to process.
        config: Configuration dict containing event settings.
        project: Project context string shown as subtitle.
    """
    settings = config["events"].get(event_type, {})
    if not settings.get("enabled", True):
        return

    cooldown = settings.get("cooldown_seconds", 0)
    if not check_cooldown(event_type, cooldown_seconds=cooldown):
        log(f"[Notify] Skipping {event_type} (cooldown)")
        return

    if send_notification(
        settings.get("title", "Claude Code"),
        message=settings.get("message", event_type),
        sound=settings.get("sound", "default"),
        subtitle=project,
    ):
        update_cooldown(event_type)
        log(f"[Notify] Sent {event_type} notification")


def main() -> int:
    """Route hook events to notification handlers.

    Returns:
        Exit code (always 0 to avoid blocking Claude).
    """
    config = load_config()
    hook_input: dict[str, Any] = {}

    try:
        hook_input = read_hook_input()
    except json.JSONDecodeError as e:
        log(f"[Notify] Invalid input: {e}")
        sys.stdout.write(json.dumps(hook_input))
        return 0

    hook_event = hook_input.get("hook_event_name", "")
    cwd = hook_input.get("cwd", "")
    session_id = hook_input.get("session_id", "")

    project = Path(cwd).name if cwd else ""
    short_id = session_id[:7] if session_id else ""
    context = f"{project} ({short_id})" if short_id else project

    event_type = None
    if hook_event == HookEvent.NOTIFICATION:
        event_type = hook_input.get("notification_type", "")
    elif hook_event == HookEvent.STOP:
        event_type = NotificationType.STOP

    if event_type:
        process_event(event_type, config=config, project=context)

    sys.stdout.write(json.dumps(hook_input))
    return 0


if __name__ == "__main__":
    sys.exit(main())
