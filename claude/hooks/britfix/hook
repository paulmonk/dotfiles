#!/usr/bin/env python3
"""
Britfix hook - converts US spellings to British.

Processes files after they're written (PostToolUse).
Credit: https://github.com/Talieisin/britfix/
"""

from __future__ import annotations

import datetime as dt
import json
import os
import re
import subprocess
import sys
from pathlib import Path
from typing import Any, Final, TextIO

# Hook event listened for.
HOOK_POST_TOOL_USE_EVENT: Final[str] = "PostToolUse"

# Directory where this hook lives.
HOOK_DIR: Final[Path] = Path(__file__).parent.resolve()

# Optional log file path. Set BRITFIX_LOG env var to enable.
LOG_FILE: Final[str] = os.getenv("BRITFIX_LOG", "")


def log(message: str) -> None:
    """Log to stderr and optionally to file.

    Args:
        message: Content to write.
    """
    sys.stderr.write(f"{message}\n")
    if LOG_FILE:
        try:
            with open(LOG_FILE, "a") as f:
                f.write(f"{dt.datetime.now().isoformat()} {message}\n")
        except IOError:
            pass


def load_config() -> dict[str, Any]:
    """Load and validate config.json.

    Returns:
        Parsed configuration dict.

    Raises:
        SystemExit: If config is missing or invalid.
    """
    config_path = HOOK_DIR / "config.json"

    if not config_path.exists():
        log(f"[Britfix Error] Config file not found: {config_path}")
        sys.exit(1)

    try:
        with open(config_path) as f:
            config = json.load(f)
    except json.JSONDecodeError as e:
        log(f"[Britfix Error] Invalid JSON in config: {e}")
        sys.exit(1)

    if "strategies" not in config or not isinstance(config["strategies"], dict):
        log("[Britfix Error] Config missing 'strategies' object")
        sys.exit(1)

    return config


def load_supported_extensions(config: dict[str, Any]) -> frozenset[str]:
    """Extract all supported extensions from config.

    Args:
        config: Parsed configuration dict.

    Returns:
        Immutable set of supported file extensions.
    """
    extensions: set[str] = set()
    for strategy_config in config["strategies"].values():
        if "extensions" in strategy_config:
            extensions.update(strategy_config["extensions"])
    return frozenset(extensions)


_CONFIG: Final = load_config()
SUPPORTED_EXTENSIONS: Final = load_supported_extensions(_CONFIG)


def read_hook_input(
    stream: TextIO = sys.stdin, *, max_size: int = 1024 * 1024
) -> dict[str, Any]:
    """Read a JSON payload from stdin without waiting for EOF.

    Claude keeps the pipe open during cancels/timeouts, so we parse
    incrementally and return as soon as we have a complete JSON object.

    Args:
        stream: Input stream to read from.
        max_size: Maximum buffer size before rejecting input.

    Returns:
        Parsed JSON object, or empty dict on EOF.

    Raises:
        json.JSONDecodeError: If input is incomplete or exceeds max size.
    """
    decoder = json.JSONDecoder()
    buffer = ""
    encoding = getattr(stream, "encoding", "utf-8") or "utf-8"
    binary_stream = getattr(stream, "buffer", None)

    if binary_stream is not None:
        read_fn = getattr(binary_stream, "read1", None) or binary_stream.read

        def _read_chunk() -> str:
            chunk = read_fn(4096)
            return chunk.decode(encoding, errors="replace") if chunk else ""
    else:

        def _read_chunk() -> str:
            return stream.read(4096)

    while True:
        chunk = _read_chunk()
        if not chunk:
            if buffer.strip():
                raise json.JSONDecodeError("Incomplete JSON input", buffer, len(buffer))
            return {}

        buffer += chunk
        if len(buffer) > max_size:
            raise json.JSONDecodeError("Input exceeds max size", buffer[:100], 0)
        buffer = buffer.lstrip()
        if not buffer:
            continue

        try:
            hook_input, _ = decoder.raw_decode(buffer)
            return hook_input
        except json.JSONDecodeError:
            continue


def run_britfix(file_path: str) -> tuple[bool, str]:
    """Run britfix on a file to convert US spellings to British.

    Args:
        file_path: Path to the file to process.

    Returns:
        Tuple of (success, message) where message describes changes or errors.
    """
    cmd = ["britfix", "--input", file_path, "--no-backup"]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)

        if result.returncode == 0:
            output = result.stdout
            if "occurrence(s)" in output:
                changes = re.findall(r"(\w+) -> (\w+): (\d+) occurrence", output)
                if changes:
                    total = sum(int(c) for _, _, c in changes)
                    details = ", ".join(f"{a}->{b}" for a, b, _ in changes)
                    return True, f"Fixed {total}: {details}"
            return True, ""
        return False, result.stderr.strip() or result.stdout.strip()

    except subprocess.TimeoutExpired:
        return False, "Timeout"
    except FileNotFoundError:
        return False, "britfix not found"
    except subprocess.SubprocessError as e:
        return False, str(e)


def process_posttooluse(hook_input: dict[str, Any]) -> dict[str, Any]:
    """Process PostToolUse hook to fix spelling in written files.

    Args:
        hook_input: The hook payload from Claude.

    Returns:
        The unmodified hook input.
    """
    tool_name = hook_input.get("tool_name", "")
    tool_input = hook_input.get("tool_input", {})

    if tool_name not in ("Write", "Edit", "MultiEdit"):
        return hook_input

    file_path = tool_input.get("file_path", "")
    if not file_path or not os.path.exists(file_path):
        return hook_input

    ext = Path(file_path).suffix.lower()
    if ext not in SUPPORTED_EXTENSIONS:
        return hook_input

    try:
        resolved = Path(file_path).resolve()
        if HOOK_DIR in resolved.parents or resolved.parent == HOOK_DIR:
            return hook_input
    except OSError:
        pass

    success, message = run_britfix(file_path)

    if message:
        prefix = "[Britfix]" if success else "[Britfix Error]"
        log(f"{prefix} {Path(file_path).name}: {message}")

    return hook_input


def main() -> int:
    """Route hook events to handlers and return the result as JSON.

    Returns:
        Exit code (always 0 to avoid blocking Claude).
    """
    hook_input: dict[str, Any] = {}
    try:
        hook_input = read_hook_input()
    except json.JSONDecodeError as e:
        log(f"[Britfix] Invalid input: {e}")
        sys.stdout.write(json.dumps(hook_input))
        return 0

    hook_event = hook_input.get("hook_event_name", "")

    if hook_event == HOOK_POST_TOOL_USE_EVENT:
        result = process_posttooluse(hook_input)
    else:
        result = hook_input

    sys.stdout.write(json.dumps(result))
    return 0


if __name__ == "__main__":
    sys.exit(main())
