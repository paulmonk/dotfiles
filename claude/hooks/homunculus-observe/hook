#!/usr/bin/env bash
#
# Homunculus Observer Hook (async, PostToolUse only)
#
# Captures tool usage observations for the continuous learning system.
# Runs asynchronously so it never blocks Claude. Each session writes to
# its own file under observations/{session_id}.jsonl to avoid races.
#
# Wired only on PostToolUse. The pre-phase carries identical context
# without the outcome, so it would be pure redundancy.

set -o errexit -o errtrace -o pipefail -o nounset

readonly HOMUNCULUS_DIR="${HOME}/.claude/homunculus"
readonly OBSERVATIONS_DIR="${HOMUNCULUS_DIR}/observations"

# Skip if the observer agent is running (avoid feedback loop).
[[ ${HOMUNCULUS_OBSERVER:-} != "1" ]] || exit 0

# Extracts relevant context from tool input based on tool type.
extract_context() {
  local tool_name="$1"
  local input="$2"
  local file_path ext name cmd pattern desc

  case "${tool_name}" in
  Write | Edit | MultiEdit)
    file_path=$(echo "${input}" | jq -r '.tool_input.file_path // empty')
    if [[ -n ${file_path} ]]; then
      ext="${file_path##*.}"
      name="${file_path##*/}"
      desc=$(echo "${input}" | jq -r '.tool_input.description // empty' | head -c 120)
      jq -n --arg ext ".${ext}" --arg name "${name}" --arg desc "${desc}" \
        '{file_ext: $ext, file_name: $name} + (if $desc != "" then {description: $desc} else {} end)'
      return
    fi
    ;;
  Bash)
    cmd=$(echo "${input}" | jq -r '.tool_input.command // empty' | awk '{print $1}')
    desc=$(echo "${input}" | jq -r '.tool_input.description // empty' | head -c 120)
    jq -n --arg cmd "${cmd}" --arg desc "${desc}" \
      '{command: $cmd} + (if $desc != "" then {description: $desc} else {} end)'
    return
    ;;
  Grep)
    pattern=$(echo "${input}" | jq -r '.tool_input.pattern // empty' | head -c 100)
    jq -n --arg p "${pattern}" '{pattern: $p}'
    return
    ;;
  Glob)
    pattern=$(echo "${input}" | jq -r '.tool_input.pattern // empty' | head -c 100)
    jq -n --arg p "${pattern}" '{pattern: $p}'
    return
    ;;
  Read)
    file_path=$(echo "${input}" | jq -r '.tool_input.file_path // empty')
    if [[ -n ${file_path} ]]; then
      name="${file_path##*/}"
      jq -n --arg name "${name}" '{file_name: $name}'
      return
    fi
    ;;
  esac
  echo "{}"
}

# Determines the outcome of a tool execution from PostToolUse output.
extract_outcome() {
  local input="$1"

  if echo "${input}" | jq -e '.tool_output.error' >/dev/null 2>&1; then
    echo '"error"'
  elif echo "${input}" | jq -e '.tool_output.blocked' >/dev/null 2>&1; then
    echo '"blocked"'
  else
    echo '"success"'
  fi
}

main() {
  local input tool_name command timestamp context outcome session_id

  mkdir -p "${OBSERVATIONS_DIR}"

  input=$(cat)

  # Extract tool name and command in a single jq call.
  tool_name=$(echo "${input}" | jq -r '.tool_name // ""')
  command=$(echo "${input}" | jq -r '.tool_input.command // ""')

  # Only track tools that reveal user preferences and workflows.
  case "${tool_name}" in
  Write | Edit | MultiEdit | Bash | Grep | Glob | Read) ;;
  *) return ;;
  esac

  # Filter out noisy bash commands that don't reveal preferences.
  if [[ ${tool_name} == "Bash" ]]; then
    case "${command}" in
    cat\ * | head\ * | tail\ * | ls\ * | pwd | tree* | wc\ *) return ;;
    git\ branch* | git\ diff* | git\ log* | git\ status* | git\ show*) return ;;
    esac
  fi

  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  context=$(extract_context "${tool_name}" "${input}")
  outcome=$(extract_outcome "${input}")
  session_id=$(echo "${input}" | jq -r '.session_id // empty')
  local obs_file="${OBSERVATIONS_DIR}/${session_id:-anonymous}.jsonl"

  # Append observation as a single JSON line.
  jq -cn \
    --arg ts "${timestamp}" \
    --arg tool "${tool_name}" \
    --argjson ctx "${context}" \
    --argjson outcome "${outcome}" \
    --arg cwd "${PWD}" \
    --arg sid "${session_id}" \
    '{timestamp: $ts, tool: $tool, context: $ctx, outcome: $outcome, cwd: $cwd} + (if $sid != "" then {session_id: $sid} else {} end)' \
    >>"${obs_file}"
}

main
