#!/usr/bin/env zsh

#------------------------------------------------------------------------------
# If you use several different terminal emulators, it's likely, that you've
# run into the problem, that pressing a special key like PageDown will just
# display a tilde instead of doing what it's supposed to.

# There is a function described in zshcontrib(1) that reads and stores
# keydefinitions for special keys, if it recognizes a terminal, it hasn't seen
# before.

# http://zshwiki.org/home/zle/bindkeys

# create a zkbd compatible hash;
# to add other keys to this hash, see: man 5 terminfo
#
#------------------------------------------------------------------------------

zmodload zsh/terminfo
typeset -A key

# macOS
if [[ "${OSTYPE}" == "darwin"* ]]; then
    # iterm - remove K prefix
    key[Home]=${terminfo[home]}
    key[End]=${terminfo[end]}
    key[Insert]=${terminfo[ich1]}
    key[Delete]=${terminfo[dch1]}
    key[Up]=${terminfo[cuu1]}
    key[Down]=${terminfo[cud1]}
    key[Left]=${terminfo[cub1]}
    key[Right]=${terminfo[cuf1]}
    key[PageUp]=${terminfo[pp]}
    key[PageDown]=${terminfo[np]}
else
    key[Home]=${terminfo[khome]}
    key[End]=${terminfo[kend]}
    key[Insert]=${terminfo[kich1]}
    key[Delete]=${terminfo[kdch1]}
    key[Up]=${terminfo[kcuu1]}
    key[Down]=${terminfo[kcud1]}
    key[Left]=${terminfo[kcub1]}
    key[Right]=${terminfo[kcuf1]}
    key[PageUp]=${terminfo[kpp]}
    key[PageDown]=${terminfo[knp]}
fi

# beginning-of-line
[[ -n ${key[Home]}     ]]  && bindkey "${key[Home]}" >/dev/null

# end-of-line
[[ -n ${key[End]}      ]]  && bindkey "${key[End]}" >/dev/null

# overwrite-mode
[[ -n ${key[Insert]}   ]]  && bindkey "${key[Insert]}" >/dev/null

# delete-char
[[ -n ${key[Delete]}   ]]  && bindkey "${key[Delete]}" >/dev/null

# up-line-or-history
[[ -n ${key[Up]}       ]]  && bindkey "${key[Up]}" >/dev/null

# down-line-or-history
[[ -n ${key[Down]}     ]]  && bindkey "${key[Down]}" >/dev/null

# backward-char
[[ -n ${key[Left]}     ]]  && bindkey "${key[Left]}" >/dev/null

# forward-char
[[ -n ${key[Right]}    ]]  && bindkey "${key[Right]}" >/dev/null

# beginning-of-buffer-or-history
[[ -n ${key[PageUp]}   ]]  && bindkey "${key[PageUp]}" >/dev/null

# end-of-buffer-or-history
[[ -n ${key[PageDown]} ]]  && bindkey "${key[PageDown]}" >/dev/null

# Finally, make sure the terminal is in application mode, when zle is
# active. Only then are the values from $terminfo valid.
if (( $+terminfo[smkx] )) && (( $+terminfo[rmkx] )); then
    function zle-line-init () {
        echoti smkx
    }
    function zle-line-finish () {
        echoti rmkx
    }
    zle -N zle-line-init
    zle -N zle-line-finish
fi

# Ctrl-R => history-incremental-search-backward
bindkey "^R" history-incremental-search-backward

# Ctrl+right => forward word
bindkey "^[[1;5C" forward-word

# Ctrl+left => backward word
bindkey "^[[1;5D" backward-word

# Ctrl+Backspace => delete a previous word
bindkey '^H' backward-kill-word

# Ctrl-Z => Switch back to Vim
fancy-ctrl-z () {
  if [[ $#BUFFER == 0 ]]; then
    BUFFER="fg"
    zle accept-line
  else
    zle push-input
    zle clear-screen
  fi
}
zle -N fancy-ctrl-z
bindkey '^Z' fancy-ctrl-z

# View manpage while editing a command
bindkey -M vicmd 'K' run-help
